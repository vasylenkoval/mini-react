{
  "version": 3,
  "sources": ["../../src/constants.ts", "../../src/jsx.ts", "../../src/dom.ts", "../../src/hooks.ts", "../../src/scheduler.ts", "../../src/fiber.ts", "../../src/memo.ts", "../../src/examples/bench.tsx"],
  "sourcesContent": ["export const EMPTY_ARR: [] = [];\nexport const EMPTY_OBJ: {} = {};\n", "import { EMPTY_ARR } from './constants.js';\n\n// @TODO: Piggy back on react typings?\ndeclare global {\n    namespace JSX {\n        interface IntrinsicElements {\n            [elemName: string]: any;\n        }\n    }\n}\nexport const propsCompareFnSymbol = Symbol('propsCompareFn');\nexport const TEXT_ELEMENT = 'TEXT';\nexport type Primitive = undefined | null | string | number | boolean;\nexport type JSXElement = {\n    type: string | FC<Props>;\n    props: Props;\n    key: string | null;\n    children: JSXElement[];\n};\nexport type Props = {\n    children?: JSXElement[] | null;\n    [key: string]: unknown;\n};\nexport type FC<T = Props> = ((props: T) => JSXElement) & {\n    [propsCompareFnSymbol]?: (prevProps: T, nextProps: T) => boolean;\n};\n\n/**\n * Prepares children for an Element. Removes child items that cannot be rendered and flattens lists.\n * @param elements - Elements to process.\n * @param children - Array to accumulate valid children into.\n */\nfunction prepareChildren(\n    elements: (JSXElement | Primitive)[],\n    children: JSXElement[] = []\n): JSXElement[] {\n    // Create Element out of primitive children.\n    for (const element of elements) {\n        const elementType = typeof element;\n        if (elementType === 'object' && element) {\n            if (Array.isArray(element)) {\n                prepareChildren(element, children);\n            } else {\n                children.push(element as JSXElement);\n            }\n            continue;\n        }\n        if (elementType === 'string' || elementType === 'number') {\n            children.push({\n                type: TEXT_ELEMENT,\n                props: { nodeValue: element },\n                children: EMPTY_ARR,\n                key: null,\n            });\n        }\n    }\n\n    return children.length ? children : EMPTY_ARR;\n}\n\n/**\n * Creates a new JSX element with the specified type, props, and children.\n */\nexport function jsx<TProps extends Props | null>(\n    type: string | FC,\n    _props: any,\n    ..._children: (JSXElement | Primitive)[]\n): JSXElement {\n    const props = _props ?? {};\n    let children = null;\n    if (_children.length > 0) {\n        children = prepareChildren(_children);\n        props.children = children;\n    }\n\n    const element: JSXElement = {\n        type,\n        props,\n        children: children as JSXElement[],\n        key: props.key !== undefined ? props.key : null,\n    };\n    return element;\n}\n", "import { TEXT_ELEMENT, Props } from './jsx.js';\n\n/**\n * Creates a DOM node for a given type.\n * @param type - DOM tag or \"TEXT\".\n * @return DOM Node.\n */\nexport function createNode(type: string): Node {\n    return type === TEXT_ELEMENT ? document.createTextNode('') : document.createElement(type);\n}\n\nconst CHILDREN_PROP = 'children';\nconst FUNCTION_PREFIX = 'on';\n\nconst isEvent = (propName: string) => propName.startsWith(FUNCTION_PREFIX);\nconst isProp = (propName: string) => propName !== CHILDREN_PROP && !isEvent(propName);\nconst getEventName = (propName: string) => propName.toLowerCase().substring(2);\nconst getPropName = (propName: string) => (propName === 'className' ? 'class' : propName);\nconst canSetDirect = (propName: string, dom: Record<string, unknown>) => {\n    // TODO(val): snippet from preact, figure out the reason why these\n    // properties have to be set with setAttribute specifically.\n    return (\n        propName != 'width' &&\n        propName != 'height' &&\n        propName != 'href' &&\n        propName != 'list' &&\n        propName != 'form' &&\n        propName != 'tabIndex' &&\n        propName != 'download' &&\n        propName != 'rowSpan' &&\n        propName != 'colSpan' &&\n        propName != 'role' &&\n        propName != 'popover' &&\n        propName in dom\n    );\n};\n\ntype EventListener = EventListenerOrEventListenerObject;\n/**\n * Adds given properties to a DOM node. Reconciles new props with previous props if provided.\n * @param fiberRef - reference to the fiber that holds this dom node\n * @param dom - DOM node to add props to.\n * @param props -  Props to add.\n * @param prevProps - Previously applied props.\n */\nexport function addProps(fiberRef: unknown, node: Node, props: Props, prevProps: Props | null) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#node.text_node\n    if (node.nodeType === 3) {\n        if (node.nodeValue !== props.nodeValue) {\n            node.nodeValue = props.nodeValue as string;\n        }\n        return;\n    }\n\n    // @TODO: figure out why buttons and some other elements do not attach id\n    // Also figure out why value is not being reset on inputs\n\n    const element = node as Element & Record<string, unknown>;\n    if (prevProps) {\n        // Resets props that are completely removed.\n        for (let propToReset in prevProps) {\n            if (propToReset in props) {\n                continue;\n            }\n            if (isProp(propToReset)) {\n                const propName = getPropName(propToReset);\n                element.removeAttribute(propName);\n            } else if (isEvent(propToReset)) {\n                element.removeEventListener(\n                    getEventName(propToReset),\n                    prevProps[propToReset] as EventListener\n                );\n            }\n        }\n    }\n\n    // Add new props, compare to previous and update only if not equal\n    for (let propToAdd in props) {\n        if (prevProps && props[propToAdd] === prevProps[propToAdd]) {\n            continue;\n        }\n        const value = props[propToAdd];\n        if (isProp(propToAdd) && typeof value === 'string') {\n            const propName = getPropName(propToAdd);\n            if (canSetDirect(propName, element)) {\n                element[propName] = value;\n            } else {\n                element.setAttribute(propName, value);\n            }\n        } else if (isEvent(propToAdd)) {\n            const eventName = getEventName(propToAdd);\n            if (prevProps && prevProps[propToAdd]) {\n                element.removeEventListener(eventName, prevProps[propToAdd] as EventListener);\n            }\n            element.addEventListener(eventName, props[propToAdd] as EventListener);\n        }\n    }\n\n    // Add reference to the current fiber node\n    element['__fiberRef'] = fiberRef;\n}\n\nconst nodeProto = globalThis.Node?.prototype;\nconst nodeInsertBefore = nodeProto?.insertBefore;\nconst nodeRemoveChild = nodeProto?.removeChild;\nconst nodeAppendChild = nodeProto?.appendChild;\n\n/**\n * Remove child from a given parent.\n */\nfunction removeChild(parent: Node, child: Node) {\n    nodeRemoveChild.call(parent, child);\n}\n\n/**\n * Append child to a given parent.\n */\nfunction appendChild(parent: Node, child: Node) {\n    nodeAppendChild.call(parent, child);\n}\n\nfunction replaceWith(oldNode: ChildNode, newNode: Node) {\n    oldNode.replaceWith(newNode);\n}\n\nfunction insertBefore(parent: Node, node: Node, beforeNode: Node | null) {\n    nodeInsertBefore.call(parent, node, beforeNode);\n}\n\nexport default { createNode, addProps, removeChild, appendChild, replaceWith, insertBefore };\n", "export enum HookTypes {\n    state,\n    effect,\n    ref,\n    memo,\n}\n\nexport type StateHook<T> = {\n    type: HookTypes.state;\n    notify: () => void;\n    value: T;\n    pending?: { value: T };\n    setter: (value: T | ((prev: T) => T)) => void;\n};\n\nexport type EffectHook = {\n    type: HookTypes.effect;\n    cleanup?: () => void;\n    deps?: unknown[];\n};\n\nexport type RefHook<T> = {\n    type: HookTypes.ref;\n    value: { current: T };\n};\n\nexport type MemoHook<T> = {\n    type: HookTypes.memo;\n    value: T;\n    deps?: unknown[];\n};\n\nexport type Hooks = (StateHook<any> | MemoHook<any> | RefHook<any> | EffectHook)[];\nexport type CleanupFunc = () => void;\nexport type EffectFunc = () => void | CleanupFunc;\n\n/**\n * State for currently processed hooks. Reset right before the component's render.\n */\nconst current: {\n    hooks: Hooks;\n    notifyOnStateChange: () => void;\n    scheduleEffect: (effect: () => void, prevCleanup: (() => void) | null) => void;\n} = {\n    hooks: [],\n    notifyOnStateChange: () => {},\n    scheduleEffect: () => {},\n};\n\n/**\n * Index of currently executing hook within a component.\n * Starts with -1, each hook will increment this value in the beginning.\n */\nlet hookIndex = -1;\n\n/**\n * Starts to record hooks for a component.\n * @param hooks - Reference to the hooks array of the component.\n * @param notifyOnStateChange - Callback for when the state hook setters are called.\n * @param scheduleEffect - Callback for when the effect needs to be scheduled.\n */\nexport function processHooks(\n    hooks: typeof current.hooks,\n    notifyOnStateChange: typeof current.notifyOnStateChange,\n    scheduleEffect: typeof current.scheduleEffect\n) {\n    // Flush state updates\n    for (const hook of hooks) {\n        if (hook.type === HookTypes.state && hook.pending) {\n            hook.value = hook.pending.value;\n            hook.pending = undefined;\n        }\n    }\n    current.hooks = hooks;\n    current.notifyOnStateChange = notifyOnStateChange;\n    current.scheduleEffect = scheduleEffect;\n    hookIndex = -1;\n}\n\n/**\n * Stores state within the component.\n * @param initState\n * @returns Current value and a setter.\n */\nexport function useState<T>(\n    initState: T | (() => T)\n): [StateHook<T>['value'], StateHook<T>['setter']] {\n    hookIndex++;\n    const oldHook = current.hooks[hookIndex] as StateHook<T>;\n    if (oldHook) {\n        oldHook.notify = current.notifyOnStateChange;\n        return [oldHook.value, oldHook.setter];\n    }\n\n    const hook: StateHook<T> = {\n        type: HookTypes.state,\n        notify: current.notifyOnStateChange,\n        value: typeof initState === 'function' ? (initState as () => T)() : initState,\n        setter(value) {\n            let lastValue = hook.pending ? hook.pending.value : hook.value;\n            let setterFn = typeof value === 'function' ? (value as (prev: T) => T) : undefined;\n            let pendingValue = setterFn ? setterFn(lastValue) : (value as T);\n            if (pendingValue === lastValue) return;\n            hook.pending = { value: pendingValue };\n            hook.notify();\n        },\n    };\n\n    current.hooks.push(hook);\n    return [hook.value, hook.setter];\n}\n\n/**\n * Helper to collect all effect cleanup functions from the hooks array.\n * @TODO: separate effects and state from a single hooks array?\n * @param hooks - Hooks array to collect effect cleanups from.\n * @param cleanups - Reference to the array to collect the cleanups in.\n */\nexport function collectEffectCleanups(hooks: Hooks) {\n    let cleanupFuncs: CleanupFunc[] | undefined;\n    for (let hook of hooks) {\n        if (hook.type === HookTypes.effect && hook.cleanup) {\n            (cleanupFuncs ?? (cleanupFuncs = [])).push(hook.cleanup);\n        }\n    }\n    return cleanupFuncs;\n}\n\n/**\n * Runs the effect and stores the cleanup function returned on the same hook.\n * @param effect - Effect to run.\n * @param hook - Hook to store the cleanup function on.\n */\nfunction executeEffect(effect: EffectFunc, hook: EffectHook) {\n    const cleanup = effect();\n    if (typeof cleanup === 'function') {\n        hook.cleanup = cleanup;\n    }\n}\n\n/**\n * Compares if new hook deps are equal to the prev deps.\n * If deps array is missing this function will return false.\n * @param newDeps - new hook deps.\n * @param prevDeps - previous hook deps.\n * @returns True if dependencies are equal.\n */\nfunction areDepsEqual(newDeps?: unknown[], prevDeps?: unknown[]): boolean {\n    if (!newDeps || !prevDeps) {\n        return false;\n    }\n\n    return (\n        newDeps.length === prevDeps.length &&\n        (newDeps.length === 0 || newDeps.every((newDep, index) => newDep === prevDeps[index]))\n    );\n}\n\n/**\n * Schedules effects to run after the component is rendered.\n * @param effect - Effect function to run. Can return an optional cleanup to run before re-execution or unmount.\n * @param deps - Array of dependencies for the effect. Effect will be re-run when these change.\n */\nexport function useEffect(effect: EffectFunc, deps?: unknown[]) {\n    hookIndex++;\n    const scheduleEffect = current.scheduleEffect;\n    const oldHook = current.hooks[hookIndex] as EffectHook;\n    if (oldHook) {\n        if (!areDepsEqual(deps, oldHook.deps)) {\n            scheduleEffect(() => executeEffect(effect, oldHook), oldHook.cleanup ?? null);\n            oldHook.deps = deps;\n        }\n        return;\n    }\n\n    const hook: EffectHook = {\n        type: HookTypes.effect,\n        deps,\n    };\n\n    current.hooks.push(hook);\n    scheduleEffect(() => executeEffect(effect, hook), null);\n}\n\n/**\n * Remembers the value returned from the callback passed.\n * Returns the same value between renders if dependencies haven't changed.\n * @param valueFn - Callback to run to get the value.\n * @param deps - Array of dependencies to compare with the previous run.\n */\nexport function useMemo<T>(valueFn: () => T, deps: unknown[]): T {\n    hookIndex++;\n    const oldHook = current.hooks[hookIndex] as MemoHook<T>;\n    if (oldHook) {\n        if (!areDepsEqual(deps, oldHook.deps)) {\n            oldHook.deps = deps;\n            oldHook.value = valueFn();\n        }\n        return oldHook.value;\n    }\n\n    const hook: MemoHook<T> = {\n        type: HookTypes.memo,\n        deps,\n        value: valueFn(),\n    };\n\n    current.hooks.push(hook);\n    return hook.value;\n}\n\n/**\n * Remembers the value passed and returns a mutable ref object.\n * @param init - Initial value to store in the ref.\n */\nexport function useRef<T>(initialValue: T): { current: T } {\n    hookIndex++;\n    const oldHook = current.hooks[hookIndex] as RefHook<T>;\n    if (oldHook) {\n        return oldHook.value;\n    }\n\n    const hook: RefHook<T> = {\n        type: HookTypes.ref,\n        value: { current: initialValue },\n    };\n\n    current.hooks.push(hook);\n    return hook.value;\n}\n\nexport type Reducer<S, A> = (state: S, action: A) => S;\nexport type Dispatch<A> = (action: A) => void;\n\n/**\n *  Alternative to useState for more complex state management.\n * @param reducer - Function to handle state changes.\n * @param initStateOrArg - Argument for the initialization function or initial state.\n * @param initFn - Function to initialize the state.\n */\nexport function useReducer<TState, TAction, TInitArg>(\n    reducer: Reducer<TState, TAction>,\n    initStateOrArg: TInitArg | TState,\n    initFn?: (arg: TInitArg | TState) => TState\n): [TState, Dispatch<TAction>] {\n    const ref = useRef<{ dispatch: Dispatch<TAction> | undefined; initState: TState }>({\n        dispatch: undefined,\n        initState: initFn ? initFn(initStateOrArg) : (initStateOrArg as TState),\n    });\n    const [state, setState] = useState(ref.current.initState);\n    if (ref.current.dispatch) {\n        return [state, ref.current.dispatch];\n    }\n    function dispatch(action: TAction) {\n        setState((prevState) => reducer(prevState, action));\n    }\n    ref.current.dispatch = dispatch;\n    return [state, dispatch];\n}\n", "/**\n * Runs the given function with a callback that can be used to check how many\n * milliseconds are left to continue running the function.\n * @param fn - The function to run.\n */\nexport function schedule(fn: (remainingMs: () => number) => void): void {\n    // For now this is a synchronous mock of the future interface.\n    return fn(defaultRemaining);\n}\n\nfunction defaultRemaining() {\n    return 100;\n}\n", "import { JSXElement, Props, FC, propsCompareFnSymbol } from './jsx.js';\nimport REAL_DOM from './dom.js';\nimport { Hooks, processHooks, collectEffectCleanups } from './hooks.js';\nimport { schedule } from './scheduler.js';\nimport { EMPTY_ARR } from './constants.js';\n\n/**\n * Effect tags used to determine what to do with the fiber after a render.\n */\nenum EffectTag {\n    /**\n     * Add to the DOM.\n     */\n    add,\n    /**\n     * Update in the DOM.\n     */\n    update,\n    /**\n     * Delete this node from the DOM.\n     */\n    delete,\n    /**\n     * Skip the node update.\n     */\n    skip,\n}\n\nconst APP_ROOT = 'root' as const;\n\nexport interface Fiber<T extends string | FC = string | FC> {\n    /**\n     * A string if it's a DOM node, a function if it's a component.\n     */\n    type: T;\n    /**\n     * The parent fiber.\n     */\n    parent: Fiber | null;\n    /**\n     * The first child fiber.\n     */\n    child: Fiber | null;\n    /**\n     * The next sibling fiber.\n     */\n    sibling: Fiber | null;\n    /**\n     * Contains a reference to the old fiber that was replaced. Used to compare old and new trees.\n     */\n    old: Fiber | null;\n    /**\n     * When TRUE indicates that the fiber is an old alternate of some other fiber.\n     */\n    isOld: boolean;\n    /**\n     * The dom node of the fiber. Only set for DOM (non-component) fibers.\n     */\n    dom: Node | null;\n    /**\n     * State node.\n     */\n    stateNode: {\n        /**\n         * Current node this state node is attached to.\n         */\n        current: Fiber;\n        /**\n         * Array of hooks.\n         */\n        hooks: Hooks;\n    } | null;\n\n    /*\n     * The effect tag of the fiber. Used to determine what to do with the fiber after a render.\n     */\n    effectTag: EffectTag;\n    /**\n     * Indicates whether the current fiber preserved it's state but got re-ordered.\n     */\n    didChangePos: boolean;\n    /**\n     * The props of the fiber.\n     */\n    props: Props;\n    /**\n     * Version of the fiber node. Incremented each time the same fiber is recreated.\n     */\n    version: number;\n    /**\n     * Same as props.children for dom nodes, computed from render for component nodes.\n     */\n    childElements: JSXElement[];\n    /**\n     * Reference to the element that created this fiber.\n     */\n    fromElement: JSXElement;\n    /**\n     * Function to compare prev and next props.\n     */\n    propsCompareFn: ((prevProps: Props, nextProps: Props) => boolean) | null;\n}\n\ntype MaybeFiber = Fiber | null;\ntype AfterCommitFunc = () => void;\ntype MaybeAfterCommitFunc = AfterCommitFunc | undefined;\n\nlet nextUnitOfWork: MaybeFiber;\nlet componentRenderQueue: Fiber[] = [];\nlet wipRoot: MaybeFiber;\nlet currentRoot: MaybeFiber;\nlet deletions: Fiber[] = [];\nlet effectsToRun: (() => void)[] = [];\nlet effectCleanupsToRun: (() => void)[] = [];\nlet afterCommitCbs: AfterCommitFunc[] = [];\nlet DOM = REAL_DOM;\n\nconst defaultShallowEqual = (_prevProps: Props, _nextProps: Props) => {\n    return false;\n};\n\nfunction getNewFiber(): Fiber {\n    const props = { key: null, children: EMPTY_ARR };\n    const fiber: Fiber = {\n        parent: null,\n        child: null,\n        sibling: null,\n        type: '',\n        props,\n        effectTag: EffectTag.add,\n        old: null,\n        isOld: false,\n        dom: null,\n        stateNode: null,\n        didChangePos: false,\n        version: 0,\n        childElements: EMPTY_ARR,\n        fromElement: {\n            type: '',\n            props,\n            children: EMPTY_ARR,\n            key: null,\n        },\n        propsCompareFn: defaultShallowEqual,\n    };\n    fiber.stateNode = {\n        current: fiber,\n        hooks: [],\n    };\n    return fiber;\n}\n\n/**\n * Creates app root and kicks off the first render.\n * @param root - The topmost DOM node to attach elements to.\n * @param element - The JSX element to render.\n * @param options - Options for the render.\n */\nexport function createRoot(root: Node, element: JSXElement, fakeDom?: typeof REAL_DOM) {\n    if (fakeDom) {\n        DOM = fakeDom;\n    }\n    const fiber = getNewFiber();\n    fiber.type = APP_ROOT;\n    fiber.dom = root;\n    fiber.props = { key: null, children: [element] };\n    fiber.fromElement = {\n        type: 'div',\n        props: fiber.props,\n        children: [element],\n        key: null,\n    };\n    wipRoot = fiber;\n    nextUnitOfWork = fiber;\n    schedule(workloop);\n}\n\n/**\n * Schedules a component to be re-rendered.\n * @param fiber - The component element to re-render.\n */\nfunction addToComponentRenderQueue(fiber: Fiber) {\n    if (!componentRenderQueue.includes(fiber)) {\n        componentRenderQueue.push(fiber);\n        schedule(workloop);\n    }\n}\n\nfunction nonSkippedAndNotPositionChanged(f: Fiber) {\n    return f.didChangePos || f.effectTag !== EffectTag.skip;\n}\n\n/**\n * Commits changes to the DOM after a render cycle has completed.\n */\nfunction commitRoot() {\n    // Process deletes first.\n    for (const fiberToDelete of deletions) {\n        deleteFiber(fiberToDelete);\n    }\n\n    deletions = [];\n\n    if (wipRoot) {\n        let nextFiberToCommit: MaybeFiber = wipRoot;\n        while (nextFiberToCommit) {\n            commitFiber(nextFiberToCommit);\n\n            nextFiberToCommit = nextFiber(\n                nextFiberToCommit,\n                wipRoot,\n                nonSkippedAndNotPositionChanged,\n                nextFiberToCommit.effectTag === EffectTag.skip\n            );\n        }\n\n        for (let i = afterCommitCbs.length - 1; i >= 0; i--) {\n            afterCommitCbs[i]();\n        }\n        afterCommitCbs.splice(0);\n\n        if (wipRoot.type === APP_ROOT) {\n            // first mount\n            currentRoot = wipRoot;\n        } else {\n            // component re-renders, attaching fiber to existing root\n            const originalFiber = wipRoot.old;\n            const parent = wipRoot.parent!;\n            let nextChild = parent.child!;\n\n            if (nextChild === originalFiber) {\n                parent.child = wipRoot;\n            } else {\n                while (nextChild) {\n                    if (nextChild.sibling === originalFiber) {\n                        nextChild.sibling = wipRoot;\n                        break;\n                    }\n                    nextChild = nextChild.sibling!;\n                }\n            }\n        }\n    }\n\n    wipRoot = null;\n\n    // Running effects in the reverse order. Leaf fibers run their effects first.\n    // @TODO: run this async\n    for (let i = effectCleanupsToRun.length - 1; i >= 0; i--) {\n        effectCleanupsToRun[i]();\n    }\n    effectCleanupsToRun.splice(0);\n\n    for (let i = effectsToRun.length - 1; i >= 0; i--) {\n        effectsToRun[i]();\n    }\n    effectsToRun.splice(0);\n}\n\nfunction withDom(f: any) {\n    return !!f.dom;\n}\n\nfunction nonComponent(f: any) {\n    return typeof f.type !== 'string';\n}\n\nfunction deleteFiber(fiber: Fiber) {\n    // Find the closest child and remove it from the dom.\n    const closestChildDOM = fiber.dom ?? findNextFiber(fiber, fiber, withDom)?.dom;\n    if (closestChildDOM && closestChildDOM.parentNode) {\n        DOM.removeChild(closestChildDOM.parentNode, closestChildDOM);\n    }\n    // Collect all of the useEffect cleanup functions to run after delete.\n    let nextComponentChildFiber: MaybeFiber = fiber;\n    while (nextComponentChildFiber) {\n        if (nextComponentChildFiber.stateNode!.hooks.length) {\n            const cleanupFuncs = collectEffectCleanups(nextComponentChildFiber.stateNode!.hooks);\n            if (cleanupFuncs) {\n                effectCleanupsToRun.push(...cleanupFuncs.reverse());\n            }\n        }\n        nextComponentChildFiber = findNextFiber(nextComponentChildFiber, fiber, nonComponent);\n    }\n    fiber.effectTag = EffectTag.delete;\n    fiber.isOld = true;\n    fiber.old = null;\n    fiber.child = null;\n    fiber.sibling = null;\n    fiber.parent = null;\n    fiber.dom = null;\n    fiber.stateNode = null;\n    fiber.childElements = EMPTY_ARR;\n}\n\n/**\n * Commits a single fiber by attaching its DOM nodes to parent's and adding new props.\n * New subtrees are mounted at once.\n * Removes nodes marked to be deleted.\n * @param fiber - Fiber to commit.\n */\nfunction commitFiber(fiber: Fiber) {\n    // if (fiber.didChangePos || fiber.effectTag === EffectTag.add) {\n    if (fiber.didChangePos) {\n        // Find closest parent that's not a component.\n        const closestChildDom = fiber.dom ?? findNextFiber(fiber, fiber, withDom)?.dom;\n        const closestNextSiblingDom = fiber.sibling\n            ? fiber.sibling?.dom ?? findNextFiber(fiber.sibling, fiber, withDom)?.dom ?? null\n            : null;\n\n        if (closestChildDom) {\n            afterCommitCbs.push(() => {\n                if (closestChildDom.nextSibling !== closestNextSiblingDom) {\n                    DOM.insertBefore(\n                        closestChildDom.parentNode!,\n                        closestChildDom,\n                        closestNextSiblingDom\n                    );\n                }\n            });\n        }\n    }\n\n    if (!(fiber.dom && fiber.parent) || fiber.effectTag === EffectTag.skip) {\n        return;\n    }\n\n    // Find closest parent that's not a component.\n    let parentWithDom: MaybeFiber = fiber.parent;\n    while (!parentWithDom.dom) {\n        parentWithDom = parentWithDom.parent!;\n    }\n\n    if (fiber.effectTag === EffectTag.update) {\n        DOM.addProps(fiber, fiber.dom, fiber.props, fiber.old?.props || null);\n    }\n\n    if (fiber.effectTag === EffectTag.add) {\n        const parent = parentWithDom.dom;\n        const child = fiber.dom;\n        DOM.appendChild(parent, child);\n    }\n\n    return;\n}\n\n/**\n * Picks the next component to render from the render queue.\n * @returns The next component to render.\n */\nfunction pickNextComponentToRender(): MaybeFiber {\n    if (!componentRenderQueue.length) {\n        return null;\n    }\n    const componentFiber = componentRenderQueue.shift()!;\n\n    // If the component already re-rendered since it was queued we can skip the update.\n    if (componentFiber.isOld) {\n        return pickNextComponentToRender();\n    }\n\n    const newFiber = getNewFiber();\n    newFiber.type = componentFiber.type;\n    newFiber.parent = componentFiber.parent;\n    newFiber.child = componentFiber.child;\n    newFiber.sibling = componentFiber.sibling;\n    newFiber.old = componentFiber;\n    newFiber.isOld = false;\n    newFiber.dom = componentFiber.dom;\n    const stateNode = componentFiber.stateNode!;\n    newFiber.stateNode = stateNode;\n    stateNode.current = newFiber;\n    newFiber.effectTag = EffectTag.update;\n    newFiber.didChangePos = false;\n    newFiber.props = componentFiber.props;\n    newFiber.version = componentFiber.version + 1;\n    newFiber.childElements = componentFiber.childElements;\n    newFiber.fromElement = componentFiber.fromElement;\n    newFiber.propsCompareFn = componentFiber.propsCompareFn;\n    // Do this after commit?\n    componentFiber.old = null;\n    componentFiber.isOld = true;\n\n    return newFiber;\n}\n\n/**\n * The main work loop. Picks up items from the render queue.\n * @param timeRemaining - Function that returns the remaining time this loop has to run.\n */\nfunction workloop(remainingMs: () => number) {\n    let shouldWait = false;\n    while (nextUnitOfWork && !shouldWait) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        shouldWait = remainingMs() < 1;\n    }\n\n    if (!nextUnitOfWork && wipRoot) {\n        commitRoot();\n    }\n\n    const nextComponent = pickNextComponentToRender();\n    if (nextComponent) {\n        wipRoot = nextComponent;\n        nextUnitOfWork = wipRoot;\n        schedule(workloop);\n        return;\n    }\n\n    if (wipRoot) {\n        schedule(workloop);\n    }\n}\n\n/**\n * Runs the component function, processes hooks and schedules effects.\n * @param fiber - The component fiber to process.\n */\nfunction processComponentFiber(fiber: Fiber<FC>) {\n    if (propsCompareFnSymbol in fiber.type && fiber.type[propsCompareFnSymbol]) {\n        fiber.propsCompareFn = fiber.type[propsCompareFnSymbol];\n    }\n\n    let componentEffects: (() => void)[] | undefined;\n    let componentEffectCleanups: (() => void)[] | undefined;\n    // Make sure notifyOnStateChange does not have to close over entire node.\n    const stateNode = fiber.stateNode!;\n\n    processHooks(\n        stateNode.hooks,\n        function notifyOnStateChange() {\n            addToComponentRenderQueue(stateNode.current!);\n        },\n        function scheduleEffect(effect, cleanup) {\n            (componentEffects ?? (componentEffects = [])).push(effect);\n            if (cleanup) {\n                (componentEffectCleanups ?? (componentEffectCleanups = [])).push(cleanup);\n            }\n        }\n    );\n\n    const element = fiber.type(fiber.props);\n    fiber.childElements = [element];\n\n    // Leaf fibers run their effects first in the order they were inside of the component.\n    // We maintain a single global array of all effects and by the end of the commit phase\n    // we will execute all effects one-by-one starting from the end of that array. Because\n    // we still need want to preserve the call order we need to reverse the effects here\n    // ahead of time.\n    if (componentEffects) {\n        effectsToRun.push(...componentEffects.reverse());\n    }\n    if (componentEffectCleanups) {\n        effectCleanupsToRun.push(...componentEffectCleanups.reverse());\n    }\n}\n\n/**\n * Processes dom fiber node before diffing children.\n * @param fiber - The dom fiber to process.\n */\nfunction processDomFiber(fiber: Fiber<string>) {\n    if (!fiber.dom) {\n        fiber.dom = DOM.createNode(fiber.type as string);\n        DOM.addProps(fiber, fiber.dom, fiber.props, null);\n    }\n    fiber.childElements = fiber.fromElement.children ?? EMPTY_ARR;\n}\n\n/**\n * Performs a single unit of work.\n * @param fiber - Fiber to do work on.\n * @returns Next unit of work or undefined if no work is left.\n */\nfunction performUnitOfWork(fiber: Fiber): MaybeFiber {\n    if (typeof fiber.type === 'string') {\n        processDomFiber(fiber as Fiber<string>);\n    }\n    if (typeof fiber.type === 'function') {\n        processComponentFiber(fiber as Fiber<FC>);\n    }\n\n    diffChildren(fiber, fiber.childElements);\n    return nextFiber(fiber, wipRoot, nonSkipped);\n}\n\nfunction nonSkipped(f: Fiber) {\n    return f.effectTag !== EffectTag.skip;\n}\n\nfunction defaultPredicate() {\n    return true;\n}\n\n/**\n * Returns the next fiber to be processed by the unit of work.\n * If skipFn is provided, it will skip subtrees that don't pass the predicate.\n * @param currFiber - Current fiber that work was done on.\n * @param root - Top fiber to return to.\n * @param continueFn - Function to filter the current node. If \"false\" is returned the current node is skipped.\n * @returns Next fiber to perform work on.\n */\nfunction nextFiber(\n    currFiber: Fiber,\n    root: MaybeFiber,\n    continueFn: (fiber: Fiber) => boolean = defaultPredicate,\n    skipChild = false\n): MaybeFiber {\n    // 1. Check child first if allowed\n    if (!skipChild && currFiber.child && continueFn(currFiber.child)) {\n        return currFiber.child;\n    }\n\n    let current: MaybeFiber = skipChild ? currFiber : currFiber.child ?? currFiber;\n\n    // 2. Traverse up ancestors\n    while (current && current !== root) {\n        // 3. Check all siblings in a single pass\n        let sibling = current.sibling;\n        while (sibling) {\n            if (continueFn(sibling)) {\n                return sibling;\n            }\n            sibling = sibling.sibling;\n        }\n\n        // 4. Move to parent if no valid siblings\n        current = current.parent;\n    }\n\n    return null;\n}\n\nfunction nextFiber2(currFiber: Fiber, root: MaybeFiber): MaybeFiber {\n    let current: MaybeFiber = currFiber;\n\n    if (current.child) {\n        return current.child;\n    }\n\n    while (current && current !== root) {\n        let sibling = current.sibling;\n        if (sibling) {\n            return sibling;\n        }\n\n        current = current.parent;\n    }\n\n    return null;\n}\n\n/**\n * Finds a next fiber in the tree that matches the predicate. Searches the entire tree until found.\n * @param currFiber - Current fiber to start the search from.\n * @param root - Root fiber to stop the search at.\n * @param predicate - Predicate to match.\n * @returns The found fiber or undefined.\n */\nfunction findNextFiber(\n    currFiber: MaybeFiber,\n    root: MaybeFiber,\n    predicate: (fiber: Fiber) => boolean\n): MaybeFiber {\n    if (!currFiber) {\n        return null;\n    }\n    let next: MaybeFiber = nextFiber2(currFiber, root);\n    while (next) {\n        if (predicate(next)) {\n            return next;\n        }\n        next = nextFiber2(next, root);\n    }\n    return null;\n}\n\nfunction diffChildren(wipFiberParent: Fiber, elements: JSXElement[]) {\n    // If fiber is a dom fiber and was previously committed and currently has no child elements\n    // but previous fiber had elements we can bail out of doing a full diff, instead just recreate\n    // the current wip fiber.\n    if (\n        !elements.length &&\n        !!wipFiberParent.dom &&\n        !!wipFiberParent.parent &&\n        !!wipFiberParent.old &&\n        !!wipFiberParent.old.child\n    ) {\n        const old = wipFiberParent.old;\n        deletions.push(old);\n\n        wipFiberParent.old = null;\n        wipFiberParent.effectTag = EffectTag.add;\n        wipFiberParent.childElements = EMPTY_ARR;\n        wipFiberParent.child = null;\n        wipFiberParent.dom = DOM.createNode(wipFiberParent.type as string);\n        DOM.addProps(wipFiberParent, wipFiberParent.dom, wipFiberParent.props, null);\n\n        return;\n    }\n\n    let oldFiber = wipFiberParent.old?.child ?? null;\n    let prevNewFiber: Fiber | null = null;\n    let index = 0;\n    const existingFibers = new Map<string | number, { fiber: Fiber; index: number }>();\n    let currentOldFiber = oldFiber;\n    let oldIndex = 0;\n\n    // Map old fibers by key with their original indices\n    while (currentOldFiber) {\n        const key = currentOldFiber.fromElement.key ?? oldIndex;\n        existingFibers.set(key, { fiber: currentOldFiber, index: oldIndex });\n        currentOldFiber = currentOldFiber.sibling;\n        oldIndex++;\n    }\n\n    // let lastPlacedIndex = 0;\n    for (let newIdx = 0; newIdx < elements.length; newIdx++) {\n        const childElement = elements[newIdx];\n        const key = childElement.key ?? newIdx;\n        const existing = existingFibers.get(key);\n        let newFiber: Fiber | null = null;\n\n        if (existing) {\n            const { fiber: oldFiber, index: oldIdx } = existing;\n            existingFibers.delete(key);\n\n            if (oldFiber.type === childElement.type) {\n                newFiber = reuseFiber(childElement, wipFiberParent, oldFiber);\n                newFiber.didChangePos = newIdx !== oldIdx;\n                // newFiber.didChangePos = newIdx !== oldIdx ? oldIdx < lastPlacedIndex : false;\n                // lastPlacedIndex = Math.max(lastPlacedIndex, oldIdx);\n\n                const shouldSkip =\n                    oldFiber.fromElement === childElement ||\n                    (typeof childElement.type !== 'string' &&\n                        newFiber.propsCompareFn?.(oldFiber.props, childElement.props));\n\n                if (shouldSkip) {\n                    // Rewire old child fibers to the new parent\n                    newFiber.effectTag = EffectTag.skip;\n                    newFiber.child = oldFiber.child;\n                    let sibling = oldFiber.child;\n                    while (sibling) {\n                        sibling.parent = newFiber;\n                        sibling = sibling.sibling;\n                    }\n                }\n                oldFiber.old = null;\n                oldFiber.isOld = true;\n                oldFiber.sibling = null;\n                oldFiber.parent = null;\n            } else {\n                // Type mismatch - delete old, create new\n                deletions.push(oldFiber);\n                newFiber = addNewFiber(childElement, wipFiberParent);\n            }\n        } else {\n            // New fiber\n            newFiber = addNewFiber(childElement, wipFiberParent);\n        }\n\n        if (newFiber) {\n            if (index === 0) wipFiberParent.child = newFiber;\n            else prevNewFiber!.sibling = newFiber;\n            prevNewFiber = newFiber;\n            index++;\n        }\n    }\n\n    // Mark remaining old fibers for deletion\n    existingFibers.forEach(({ fiber }) => deletions.push(fiber));\n}\n\nfunction addNewFiber(element: JSXElement, parent: Fiber): Fiber {\n    const newFiber = getNewFiber();\n    newFiber.type = element.type;\n    newFiber.parent = parent;\n    newFiber.props = element.props;\n    newFiber.fromElement = element;\n    newFiber.effectTag = EffectTag.add;\n    if (typeof element.type === 'string') {\n        newFiber.propsCompareFn = defaultShallowEqual;\n    }\n    return newFiber;\n}\n\nfunction reuseFiber(element: JSXElement, parent: Fiber, oldFiber: Fiber): Fiber {\n    const newFiber = getNewFiber();\n    newFiber.type = element.type;\n    newFiber.parent = parent;\n    newFiber.old = oldFiber;\n    newFiber.dom = oldFiber.dom;\n    newFiber.effectTag = EffectTag.update;\n    newFiber.props = element.props;\n    newFiber.version = oldFiber.version + 1;\n    newFiber.fromElement = element;\n    newFiber.propsCompareFn = oldFiber.propsCompareFn;\n\n    const stateNode = oldFiber.stateNode!;\n    stateNode.current = newFiber;\n    newFiber.stateNode = stateNode;\n\n    return newFiber;\n}\n", "import { JSXElement, Props, propsCompareFnSymbol } from './jsx.js';\n\nexport function shallowEqual(prevProps: Props, nextProps: Props): boolean {\n    if (prevProps === nextProps) return true;\n\n    const prevKeys = Object.keys(prevProps);\n    const nextKeys = Object.keys(nextProps);\n\n    if (prevKeys.length !== nextKeys.length) return false;\n\n    for (let i = 0; i < prevKeys.length; i++) {\n        const key = prevKeys[i];\n        if (prevProps[key] !== nextProps[key]) return false;\n    }\n\n    return true;\n}\n\nexport function memo<T extends (...args: any[]) => any, TProps extends Props = Parameters<T>[0]>(\n    Component: T,\n    compareFn: (prevProps: TProps, nextProps: TProps) => boolean = shallowEqual\n): T {\n    function Memo(props: Props): JSXElement {\n        // @ts-ignore\n        return Component(props);\n    }\n    Memo[propsCompareFnSymbol] = compareFn;\n    return Memo as unknown as T;\n}\n", "/** @jsx jsx */\nimport { jsx } from '../jsx.js';\nimport { createRoot } from '../fiber.js';\nimport { useMemo, useReducer } from '../hooks.js';\nimport { memo } from '../memo.js';\n\nconst random = (max: any) => Math.round(Math.random() * 1000) % max;\n\nconst A = [\n    'pretty',\n    'large',\n    'big',\n    'small',\n    'tall',\n    'short',\n    'long',\n    'handsome',\n    'plain',\n    'quaint',\n    'clean',\n    'elegant',\n    'easy',\n    'angry',\n    'crazy',\n    'helpful',\n    'mushy',\n    'odd',\n    'unsightly',\n    'adorable',\n    'important',\n    'inexpensive',\n    'cheap',\n    'expensive',\n    'fancy',\n];\nconst C = [\n    'red',\n    'yellow',\n    'blue',\n    'green',\n    'pink',\n    'brown',\n    'purple',\n    'brown',\n    'white',\n    'black',\n    'orange',\n];\nconst N = [\n    'table',\n    'chair',\n    'house',\n    'bbq',\n    'desk',\n    'car',\n    'pony',\n    'cookie',\n    'sandwich',\n    'burger',\n    'pizza',\n    'mouse',\n    'keyboard',\n];\n\nlet nextId = 1;\n\n// @ts-ignore\nconst buildData = (count) => {\n    const data = new Array(count);\n\n    for (let i = 0; i < count; i++) {\n        data[i] = {\n            id: nextId++,\n            label: `${A[random(A.length)]} ${C[random(C.length)]} ${N[random(N.length)]}`,\n        };\n    }\n\n    return data;\n};\n\nconst initialState = { data: [], selected: 0 };\n// @ts-ignore\nconst listReducer = (state, action) => {\n    const { data, selected } = state;\n\n    switch (action.type) {\n        case 'RUN':\n            return { data: buildData(100), selected: 0 };\n        case 'RUN_LOTS':\n            return { data: buildData(10000), selected: 0 };\n        case 'ADD':\n            return { data: data.concat(buildData(1000)), selected };\n        case 'UPDATE': {\n            const newData = data.slice(0);\n\n            for (let i = 0; i < newData.length; i += 10) {\n                const r = newData[i];\n\n                newData[i] = { id: r.id, label: r.label + ' !!!' };\n            }\n\n            return { data: newData, selected };\n        }\n        case 'CLEAR':\n            return { data: [], selected: 0 };\n        case 'SWAP_ROWS':\n            const newdata = [...data];\n            if (data.length > 998) {\n                const d1 = newdata[1];\n                const d998 = newdata[998];\n                newdata[1] = d998;\n                newdata[998] = d1;\n            }\n            return { data: newdata, selected };\n        case 'REMOVE': {\n            const idx = data.findIndex((d: any) => d.id === action.id);\n\n            return { data: [...data.slice(0, idx), ...data.slice(idx + 1)], selected };\n        }\n        case 'SELECT':\n            return { data, selected: action.id };\n        default:\n            return state;\n    }\n};\n\nconst Row = memo(\n    ({ selected, item, dispatch }: any) => (\n        <tr className={selected ? 'danger' : ''}>\n            <td className=\"col-md-1\">{item.id}</td>\n            <td className=\"col-md-4\">\n                <a onClick={useMemo(() => () => dispatch({ type: 'SELECT', id: item.id }), [])}>\n                    {item.label}\n                </a>\n            </td>\n            <td className=\"col-md-1\">\n                <a onClick={useMemo(() => () => dispatch({ type: 'REMOVE', id: item.id }), [])}>\n                    <span className=\"glyphicon glyphicon-remove\" aria-hidden=\"true\" />\n                </a>\n            </td>\n            <td className=\"col-md-6\" />\n        </tr>\n    ),\n    (prevProps, nextProps) => {\n        return prevProps.selected === nextProps.selected && prevProps.item === nextProps.item;\n    }\n);\n\nconst Button = ({ id, cb, title }: any) => (\n    <div className=\"col-sm-6 smallpad\">\n        <button type=\"button\" className=\"btn btn-primary btn-block\" id={id} onClick={cb}>\n            {title}\n        </button>\n    </div>\n);\n\nconst Jumbotron = memo(\n    // @ts-ignore\n    ({ dispatch }) => (\n        <div className=\"jumbotron\">\n            <div className=\"row\">\n                <div className=\"col-md-6\">\n                    <h1>React Hooks keyed</h1>\n                </div>\n                <div className=\"col-md-6\">\n                    <div className=\"row\">\n                        <Button\n                            id=\"run\"\n                            title=\"Create 1,000 rows\"\n                            cb={() => dispatch({ type: 'RUN' })}\n                        />\n                        <Button\n                            id=\"runlots\"\n                            title=\"Create 10,000 rows\"\n                            cb={() => dispatch({ type: 'RUN_LOTS' })}\n                        />\n                        <Button\n                            id=\"add\"\n                            title=\"Append 1,000 rows\"\n                            cb={() => dispatch({ type: 'ADD' })}\n                        />\n                        <Button\n                            id=\"update\"\n                            title=\"Update every 10th row\"\n                            cb={() => dispatch({ type: 'UPDATE' })}\n                        />\n                        <Button id=\"clear\" title=\"Clear\" cb={() => dispatch({ type: 'CLEAR' })} />\n                        <Button\n                            id=\"swaprows\"\n                            title=\"Swap Rows\"\n                            cb={() => dispatch({ type: 'SWAP_ROWS' })}\n                        />\n                    </div>\n                </div>\n            </div>\n        </div>\n    ),\n    () => true\n);\n\nconst Main = () => {\n    const [{ data, selected }, dispatch] = useReducer(listReducer, initialState);\n\n    return (\n        <div className=\"container\">\n            <Jumbotron dispatch={dispatch} />\n            <table className=\"table table-hover table-striped test-data\">\n                <tbody>\n                    {data.map((item: any) => (\n                        <Row\n                            key={item.id}\n                            item={item}\n                            selected={selected === item.id}\n                            dispatch={dispatch}\n                        />\n                    ))}\n                </tbody>\n            </table>\n            <span className=\"preloadicon glyphicon glyphicon-remove\" aria-hidden=\"true\" />\n        </div>\n    );\n};\n\ncreateRoot(document.getElementById('root')!, <Main />);\n"],
  "mappings": ";AAAO,IAAM,YAAgB,CAAC;;;ACUvB,IAAM,uBAAuB,OAAO,gBAAgB;AACpD,IAAM,eAAe;AAqB5B,SAAS,gBACL,UACA,WAAyB,CAAC,GACd;AAEZ,aAAW,WAAW,UAAU;AAC5B,UAAM,cAAc,OAAO;AAC3B,QAAI,gBAAgB,YAAY,SAAS;AACrC,UAAI,MAAM,QAAQ,OAAO,GAAG;AACxB,wBAAgB,SAAS,QAAQ;AAAA,MACrC,OAAO;AACH,iBAAS,KAAK,OAAqB;AAAA,MACvC;AACA;AAAA,IACJ;AACA,QAAI,gBAAgB,YAAY,gBAAgB,UAAU;AACtD,eAAS,KAAK;AAAA,QACV,MAAM;AAAA,QACN,OAAO,EAAE,WAAW,QAAQ;AAAA,QAC5B,UAAU;AAAA,QACV,KAAK;AAAA,MACT,CAAC;AAAA,IACL;AAAA,EACJ;AAEA,SAAO,SAAS,SAAS,WAAW;AACxC;AAKO,SAAS,IACZ,MACA,WACG,WACO;AACV,QAAM,QAAQ,UAAU,CAAC;AACzB,MAAI,WAAW;AACf,MAAI,UAAU,SAAS,GAAG;AACtB,eAAW,gBAAgB,SAAS;AACpC,UAAM,WAAW;AAAA,EACrB;AAEA,QAAM,UAAsB;AAAA,IACxB;AAAA,IACA;AAAA,IACA;AAAA,IACA,KAAK,MAAM,QAAQ,SAAY,MAAM,MAAM;AAAA,EAC/C;AACA,SAAO;AACX;;;AC3EO,SAAS,WAAW,MAAoB;AAC3C,SAAO,SAAS,eAAe,SAAS,eAAe,EAAE,IAAI,SAAS,cAAc,IAAI;AAC5F;AAEA,IAAM,gBAAgB;AACtB,IAAM,kBAAkB;AAExB,IAAM,UAAU,CAAC,aAAqB,SAAS,WAAW,eAAe;AACzE,IAAM,SAAS,CAAC,aAAqB,aAAa,iBAAiB,CAAC,QAAQ,QAAQ;AACpF,IAAM,eAAe,CAAC,aAAqB,SAAS,YAAY,EAAE,UAAU,CAAC;AAC7E,IAAM,cAAc,CAAC,aAAsB,aAAa,cAAc,UAAU;AAChF,IAAM,eAAe,CAAC,UAAkB,QAAiC;AAGrE,SACI,YAAY,WACZ,YAAY,YACZ,YAAY,UACZ,YAAY,UACZ,YAAY,UACZ,YAAY,cACZ,YAAY,cACZ,YAAY,aACZ,YAAY,aACZ,YAAY,UACZ,YAAY,aACZ,YAAY;AAEpB;AAUO,SAAS,SAAS,UAAmB,MAAY,OAAc,WAAyB;AAE3F,MAAI,KAAK,aAAa,GAAG;AACrB,QAAI,KAAK,cAAc,MAAM,WAAW;AACpC,WAAK,YAAY,MAAM;AAAA,IAC3B;AACA;AAAA,EACJ;AAKA,QAAM,UAAU;AAChB,MAAI,WAAW;AAEX,aAAS,eAAe,WAAW;AAC/B,UAAI,eAAe,OAAO;AACtB;AAAA,MACJ;AACA,UAAI,OAAO,WAAW,GAAG;AACrB,cAAM,WAAW,YAAY,WAAW;AACxC,gBAAQ,gBAAgB,QAAQ;AAAA,MACpC,WAAW,QAAQ,WAAW,GAAG;AAC7B,gBAAQ;AAAA,UACJ,aAAa,WAAW;AAAA,UACxB,UAAU,WAAW;AAAA,QACzB;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAGA,WAAS,aAAa,OAAO;AACzB,QAAI,aAAa,MAAM,SAAS,MAAM,UAAU,SAAS,GAAG;AACxD;AAAA,IACJ;AACA,UAAM,QAAQ,MAAM,SAAS;AAC7B,QAAI,OAAO,SAAS,KAAK,OAAO,UAAU,UAAU;AAChD,YAAM,WAAW,YAAY,SAAS;AACtC,UAAI,aAAa,UAAU,OAAO,GAAG;AACjC,gBAAQ,QAAQ,IAAI;AAAA,MACxB,OAAO;AACH,gBAAQ,aAAa,UAAU,KAAK;AAAA,MACxC;AAAA,IACJ,WAAW,QAAQ,SAAS,GAAG;AAC3B,YAAM,YAAY,aAAa,SAAS;AACxC,UAAI,aAAa,UAAU,SAAS,GAAG;AACnC,gBAAQ,oBAAoB,WAAW,UAAU,SAAS,CAAkB;AAAA,MAChF;AACA,cAAQ,iBAAiB,WAAW,MAAM,SAAS,CAAkB;AAAA,IACzE;AAAA,EACJ;AAGA,UAAQ,YAAY,IAAI;AAC5B;AAEA,IAAM,YAAY,WAAW,MAAM;AACnC,IAAM,mBAAmB,WAAW;AACpC,IAAM,kBAAkB,WAAW;AACnC,IAAM,kBAAkB,WAAW;AAKnC,SAAS,YAAY,QAAc,OAAa;AAC5C,kBAAgB,KAAK,QAAQ,KAAK;AACtC;AAKA,SAAS,YAAY,QAAc,OAAa;AAC5C,kBAAgB,KAAK,QAAQ,KAAK;AACtC;AAEA,SAAS,YAAY,SAAoB,SAAe;AACpD,UAAQ,YAAY,OAAO;AAC/B;AAEA,SAAS,aAAa,QAAc,MAAY,YAAyB;AACrE,mBAAiB,KAAK,QAAQ,MAAM,UAAU;AAClD;AAEA,IAAO,cAAQ,EAAE,YAAY,UAAU,aAAa,aAAa,aAAa,aAAa;;;AC1F3F,IAAM,UAIF;AAAA,EACA,OAAO,CAAC;AAAA,EACR,qBAAqB,MAAM;AAAA,EAAC;AAAA,EAC5B,gBAAgB,MAAM;AAAA,EAAC;AAC3B;AAMA,IAAI,YAAY;AAQT,SAAS,aACZ,OACA,qBACA,gBACF;AAEE,aAAW,QAAQ,OAAO;AACtB,QAAI,KAAK,SAAS,iBAAmB,KAAK,SAAS;AAC/C,WAAK,QAAQ,KAAK,QAAQ;AAC1B,WAAK,UAAU;AAAA,IACnB;AAAA,EACJ;AACA,UAAQ,QAAQ;AAChB,UAAQ,sBAAsB;AAC9B,UAAQ,iBAAiB;AACzB,cAAY;AAChB;AAOO,SAAS,SACZ,WAC+C;AAC/C;AACA,QAAM,UAAU,QAAQ,MAAM,SAAS;AACvC,MAAI,SAAS;AACT,YAAQ,SAAS,QAAQ;AACzB,WAAO,CAAC,QAAQ,OAAO,QAAQ,MAAM;AAAA,EACzC;AAEA,QAAM,OAAqB;AAAA,IACvB,MAAM;AAAA,IACN,QAAQ,QAAQ;AAAA,IAChB,OAAO,OAAO,cAAc,aAAc,UAAsB,IAAI;AAAA,IACpE,OAAO,OAAO;AACV,UAAI,YAAY,KAAK,UAAU,KAAK,QAAQ,QAAQ,KAAK;AACzD,UAAI,WAAW,OAAO,UAAU,aAAc,QAA2B;AACzE,UAAI,eAAe,WAAW,SAAS,SAAS,IAAK;AACrD,UAAI,iBAAiB,UAAW;AAChC,WAAK,UAAU,EAAE,OAAO,aAAa;AACrC,WAAK,OAAO;AAAA,IAChB;AAAA,EACJ;AAEA,UAAQ,MAAM,KAAK,IAAI;AACvB,SAAO,CAAC,KAAK,OAAO,KAAK,MAAM;AACnC;AAQO,SAAS,sBAAsB,OAAc;AAChD,MAAI;AACJ,WAAS,QAAQ,OAAO;AACpB,QAAI,KAAK,SAAS,kBAAoB,KAAK,SAAS;AAChD,OAAC,iBAAiB,eAAe,CAAC,IAAI,KAAK,KAAK,OAAO;AAAA,IAC3D;AAAA,EACJ;AACA,SAAO;AACX;AAqBA,SAAS,aAAa,SAAqB,UAA+B;AACtE,MAAI,CAAC,WAAW,CAAC,UAAU;AACvB,WAAO;AAAA,EACX;AAEA,SACI,QAAQ,WAAW,SAAS,WAC3B,QAAQ,WAAW,KAAK,QAAQ,MAAM,CAAC,QAAQ,UAAU,WAAW,SAAS,KAAK,CAAC;AAE5F;AAkCO,SAAS,QAAW,SAAkB,MAAoB;AAC7D;AACA,QAAM,UAAU,QAAQ,MAAM,SAAS;AACvC,MAAI,SAAS;AACT,QAAI,CAAC,aAAa,MAAM,QAAQ,IAAI,GAAG;AACnC,cAAQ,OAAO;AACf,cAAQ,QAAQ,QAAQ;AAAA,IAC5B;AACA,WAAO,QAAQ;AAAA,EACnB;AAEA,QAAM,OAAoB;AAAA,IACtB,MAAM;AAAA,IACN;AAAA,IACA,OAAO,QAAQ;AAAA,EACnB;AAEA,UAAQ,MAAM,KAAK,IAAI;AACvB,SAAO,KAAK;AAChB;AAMO,SAAS,OAAU,cAAiC;AACvD;AACA,QAAM,UAAU,QAAQ,MAAM,SAAS;AACvC,MAAI,SAAS;AACT,WAAO,QAAQ;AAAA,EACnB;AAEA,QAAM,OAAmB;AAAA,IACrB,MAAM;AAAA,IACN,OAAO,EAAE,SAAS,aAAa;AAAA,EACnC;AAEA,UAAQ,MAAM,KAAK,IAAI;AACvB,SAAO,KAAK;AAChB;AAWO,SAAS,WACZ,SACA,gBACA,QAC2B;AAC3B,QAAM,MAAM,OAAuE;AAAA,IAC/E,UAAU;AAAA,IACV,WAAW,SAAS,OAAO,cAAc,IAAK;AAAA,EAClD,CAAC;AACD,QAAM,CAAC,OAAO,QAAQ,IAAI,SAAS,IAAI,QAAQ,SAAS;AACxD,MAAI,IAAI,QAAQ,UAAU;AACtB,WAAO,CAAC,OAAO,IAAI,QAAQ,QAAQ;AAAA,EACvC;AACA,WAAS,SAAS,QAAiB;AAC/B,aAAS,CAAC,cAAc,QAAQ,WAAW,MAAM,CAAC;AAAA,EACtD;AACA,MAAI,QAAQ,WAAW;AACvB,SAAO,CAAC,OAAO,QAAQ;AAC3B;;;AC7PO,SAAS,SAAS,IAA+C;AAEpE,SAAO,GAAG,gBAAgB;AAC9B;AAEA,SAAS,mBAAmB;AACxB,SAAO;AACX;;;ACgBA,IAAM,WAAW;AA+EjB,IAAI;AACJ,IAAI,uBAAgC,CAAC;AACrC,IAAI;AACJ,IAAI;AACJ,IAAI,YAAqB,CAAC;AAC1B,IAAI,eAA+B,CAAC;AACpC,IAAI,sBAAsC,CAAC;AAC3C,IAAI,iBAAoC,CAAC;AACzC,IAAI,MAAM;AAEV,IAAM,sBAAsB,CAAC,YAAmB,eAAsB;AAClE,SAAO;AACX;AAEA,SAAS,cAAqB;AAC1B,QAAM,QAAQ,EAAE,KAAK,MAAM,UAAU,UAAU;AAC/C,QAAM,QAAe;AAAA,IACjB,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,SAAS;AAAA,IACT,MAAM;AAAA,IACN;AAAA,IACA,WAAW;AAAA,IACX,KAAK;AAAA,IACL,OAAO;AAAA,IACP,KAAK;AAAA,IACL,WAAW;AAAA,IACX,cAAc;AAAA,IACd,SAAS;AAAA,IACT,eAAe;AAAA,IACf,aAAa;AAAA,MACT,MAAM;AAAA,MACN;AAAA,MACA,UAAU;AAAA,MACV,KAAK;AAAA,IACT;AAAA,IACA,gBAAgB;AAAA,EACpB;AACA,QAAM,YAAY;AAAA,IACd,SAAS;AAAA,IACT,OAAO,CAAC;AAAA,EACZ;AACA,SAAO;AACX;AAQO,SAAS,WAAW,MAAY,SAAqB,SAA2B;AACnF,MAAI,SAAS;AACT,UAAM;AAAA,EACV;AACA,QAAM,QAAQ,YAAY;AAC1B,QAAM,OAAO;AACb,QAAM,MAAM;AACZ,QAAM,QAAQ,EAAE,KAAK,MAAM,UAAU,CAAC,OAAO,EAAE;AAC/C,QAAM,cAAc;AAAA,IAChB,MAAM;AAAA,IACN,OAAO,MAAM;AAAA,IACb,UAAU,CAAC,OAAO;AAAA,IAClB,KAAK;AAAA,EACT;AACA,YAAU;AACV,mBAAiB;AACjB,WAAS,QAAQ;AACrB;AAMA,SAAS,0BAA0B,OAAc;AAC7C,MAAI,CAAC,qBAAqB,SAAS,KAAK,GAAG;AACvC,yBAAqB,KAAK,KAAK;AAC/B,aAAS,QAAQ;AAAA,EACrB;AACJ;AAEA,SAAS,gCAAgC,GAAU;AAC/C,SAAO,EAAE,gBAAgB,EAAE,cAAc;AAC7C;AAKA,SAAS,aAAa;AAElB,aAAW,iBAAiB,WAAW;AACnC,gBAAY,aAAa;AAAA,EAC7B;AAEA,cAAY,CAAC;AAEb,MAAI,SAAS;AACT,QAAI,oBAAgC;AACpC,WAAO,mBAAmB;AACtB,kBAAY,iBAAiB;AAE7B,0BAAoB;AAAA,QAChB;AAAA,QACA;AAAA,QACA;AAAA,QACA,kBAAkB,cAAc;AAAA,MACpC;AAAA,IACJ;AAEA,aAAS,IAAI,eAAe,SAAS,GAAG,KAAK,GAAG,KAAK;AACjD,qBAAe,CAAC,EAAE;AAAA,IACtB;AACA,mBAAe,OAAO,CAAC;AAEvB,QAAI,QAAQ,SAAS,UAAU;AAE3B,oBAAc;AAAA,IAClB,OAAO;AAEH,YAAM,gBAAgB,QAAQ;AAC9B,YAAM,SAAS,QAAQ;AACvB,UAAI,YAAY,OAAO;AAEvB,UAAI,cAAc,eAAe;AAC7B,eAAO,QAAQ;AAAA,MACnB,OAAO;AACH,eAAO,WAAW;AACd,cAAI,UAAU,YAAY,eAAe;AACrC,sBAAU,UAAU;AACpB;AAAA,UACJ;AACA,sBAAY,UAAU;AAAA,QAC1B;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAEA,YAAU;AAIV,WAAS,IAAI,oBAAoB,SAAS,GAAG,KAAK,GAAG,KAAK;AACtD,wBAAoB,CAAC,EAAE;AAAA,EAC3B;AACA,sBAAoB,OAAO,CAAC;AAE5B,WAAS,IAAI,aAAa,SAAS,GAAG,KAAK,GAAG,KAAK;AAC/C,iBAAa,CAAC,EAAE;AAAA,EACpB;AACA,eAAa,OAAO,CAAC;AACzB;AAEA,SAAS,QAAQ,GAAQ;AACrB,SAAO,CAAC,CAAC,EAAE;AACf;AAEA,SAAS,aAAa,GAAQ;AAC1B,SAAO,OAAO,EAAE,SAAS;AAC7B;AAEA,SAAS,YAAY,OAAc;AAE/B,QAAM,kBAAkB,MAAM,OAAO,cAAc,OAAO,OAAO,OAAO,GAAG;AAC3E,MAAI,mBAAmB,gBAAgB,YAAY;AAC/C,QAAI,YAAY,gBAAgB,YAAY,eAAe;AAAA,EAC/D;AAEA,MAAI,0BAAsC;AAC1C,SAAO,yBAAyB;AAC5B,QAAI,wBAAwB,UAAW,MAAM,QAAQ;AACjD,YAAM,eAAe,sBAAsB,wBAAwB,UAAW,KAAK;AACnF,UAAI,cAAc;AACd,4BAAoB,KAAK,GAAG,aAAa,QAAQ,CAAC;AAAA,MACtD;AAAA,IACJ;AACA,8BAA0B,cAAc,yBAAyB,OAAO,YAAY;AAAA,EACxF;AACA,QAAM,YAAY;AAClB,QAAM,QAAQ;AACd,QAAM,MAAM;AACZ,QAAM,QAAQ;AACd,QAAM,UAAU;AAChB,QAAM,SAAS;AACf,QAAM,MAAM;AACZ,QAAM,YAAY;AAClB,QAAM,gBAAgB;AAC1B;AAQA,SAAS,YAAY,OAAc;AAE/B,MAAI,MAAM,cAAc;AAEpB,UAAM,kBAAkB,MAAM,OAAO,cAAc,OAAO,OAAO,OAAO,GAAG;AAC3E,UAAM,wBAAwB,MAAM,UAC9B,MAAM,SAAS,OAAO,cAAc,MAAM,SAAS,OAAO,OAAO,GAAG,OAAO,OAC3E;AAEN,QAAI,iBAAiB;AACjB,qBAAe,KAAK,MAAM;AACtB,YAAI,gBAAgB,gBAAgB,uBAAuB;AACvD,cAAI;AAAA,YACA,gBAAgB;AAAA,YAChB;AAAA,YACA;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AAEA,MAAI,EAAE,MAAM,OAAO,MAAM,WAAW,MAAM,cAAc,cAAgB;AACpE;AAAA,EACJ;AAGA,MAAI,gBAA4B,MAAM;AACtC,SAAO,CAAC,cAAc,KAAK;AACvB,oBAAgB,cAAc;AAAA,EAClC;AAEA,MAAI,MAAM,cAAc,gBAAkB;AACtC,QAAI,SAAS,OAAO,MAAM,KAAK,MAAM,OAAO,MAAM,KAAK,SAAS,IAAI;AAAA,EACxE;AAEA,MAAI,MAAM,cAAc,aAAe;AACnC,UAAM,SAAS,cAAc;AAC7B,UAAM,QAAQ,MAAM;AACpB,QAAI,YAAY,QAAQ,KAAK;AAAA,EACjC;AAEA;AACJ;AAMA,SAAS,4BAAwC;AAC7C,MAAI,CAAC,qBAAqB,QAAQ;AAC9B,WAAO;AAAA,EACX;AACA,QAAM,iBAAiB,qBAAqB,MAAM;AAGlD,MAAI,eAAe,OAAO;AACtB,WAAO,0BAA0B;AAAA,EACrC;AAEA,QAAM,WAAW,YAAY;AAC7B,WAAS,OAAO,eAAe;AAC/B,WAAS,SAAS,eAAe;AACjC,WAAS,QAAQ,eAAe;AAChC,WAAS,UAAU,eAAe;AAClC,WAAS,MAAM;AACf,WAAS,QAAQ;AACjB,WAAS,MAAM,eAAe;AAC9B,QAAM,YAAY,eAAe;AACjC,WAAS,YAAY;AACrB,YAAU,UAAU;AACpB,WAAS,YAAY;AACrB,WAAS,eAAe;AACxB,WAAS,QAAQ,eAAe;AAChC,WAAS,UAAU,eAAe,UAAU;AAC5C,WAAS,gBAAgB,eAAe;AACxC,WAAS,cAAc,eAAe;AACtC,WAAS,iBAAiB,eAAe;AAEzC,iBAAe,MAAM;AACrB,iBAAe,QAAQ;AAEvB,SAAO;AACX;AAMA,SAAS,SAAS,aAA2B;AACzC,MAAI,aAAa;AACjB,SAAO,kBAAkB,CAAC,YAAY;AAClC,qBAAiB,kBAAkB,cAAc;AACjD,iBAAa,YAAY,IAAI;AAAA,EACjC;AAEA,MAAI,CAAC,kBAAkB,SAAS;AAC5B,eAAW;AAAA,EACf;AAEA,QAAM,gBAAgB,0BAA0B;AAChD,MAAI,eAAe;AACf,cAAU;AACV,qBAAiB;AACjB,aAAS,QAAQ;AACjB;AAAA,EACJ;AAEA,MAAI,SAAS;AACT,aAAS,QAAQ;AAAA,EACrB;AACJ;AAMA,SAAS,sBAAsB,OAAkB;AAC7C,MAAI,wBAAwB,MAAM,QAAQ,MAAM,KAAK,oBAAoB,GAAG;AACxE,UAAM,iBAAiB,MAAM,KAAK,oBAAoB;AAAA,EAC1D;AAEA,MAAI;AACJ,MAAI;AAEJ,QAAM,YAAY,MAAM;AAExB;AAAA,IACI,UAAU;AAAA,IACV,SAAS,sBAAsB;AAC3B,gCAA0B,UAAU,OAAQ;AAAA,IAChD;AAAA,IACA,SAAS,eAAe,QAAQ,SAAS;AACrC,OAAC,qBAAqB,mBAAmB,CAAC,IAAI,KAAK,MAAM;AACzD,UAAI,SAAS;AACT,SAAC,4BAA4B,0BAA0B,CAAC,IAAI,KAAK,OAAO;AAAA,MAC5E;AAAA,IACJ;AAAA,EACJ;AAEA,QAAM,UAAU,MAAM,KAAK,MAAM,KAAK;AACtC,QAAM,gBAAgB,CAAC,OAAO;AAO9B,MAAI,kBAAkB;AAClB,iBAAa,KAAK,GAAG,iBAAiB,QAAQ,CAAC;AAAA,EACnD;AACA,MAAI,yBAAyB;AACzB,wBAAoB,KAAK,GAAG,wBAAwB,QAAQ,CAAC;AAAA,EACjE;AACJ;AAMA,SAAS,gBAAgB,OAAsB;AAC3C,MAAI,CAAC,MAAM,KAAK;AACZ,UAAM,MAAM,IAAI,WAAW,MAAM,IAAc;AAC/C,QAAI,SAAS,OAAO,MAAM,KAAK,MAAM,OAAO,IAAI;AAAA,EACpD;AACA,QAAM,gBAAgB,MAAM,YAAY,YAAY;AACxD;AAOA,SAAS,kBAAkB,OAA0B;AACjD,MAAI,OAAO,MAAM,SAAS,UAAU;AAChC,oBAAgB,KAAsB;AAAA,EAC1C;AACA,MAAI,OAAO,MAAM,SAAS,YAAY;AAClC,0BAAsB,KAAkB;AAAA,EAC5C;AAEA,eAAa,OAAO,MAAM,aAAa;AACvC,SAAO,UAAU,OAAO,SAAS,UAAU;AAC/C;AAEA,SAAS,WAAW,GAAU;AAC1B,SAAO,EAAE,cAAc;AAC3B;AAEA,SAAS,mBAAmB;AACxB,SAAO;AACX;AAUA,SAAS,UACL,WACA,MACA,aAAwC,kBACxC,YAAY,OACF;AAEV,MAAI,CAAC,aAAa,UAAU,SAAS,WAAW,UAAU,KAAK,GAAG;AAC9D,WAAO,UAAU;AAAA,EACrB;AAEA,MAAIA,WAAsB,YAAY,YAAY,UAAU,SAAS;AAGrE,SAAOA,YAAWA,aAAY,MAAM;AAEhC,QAAI,UAAUA,SAAQ;AACtB,WAAO,SAAS;AACZ,UAAI,WAAW,OAAO,GAAG;AACrB,eAAO;AAAA,MACX;AACA,gBAAU,QAAQ;AAAA,IACtB;AAGA,IAAAA,WAAUA,SAAQ;AAAA,EACtB;AAEA,SAAO;AACX;AAEA,SAAS,WAAW,WAAkB,MAA8B;AAChE,MAAIA,WAAsB;AAE1B,MAAIA,SAAQ,OAAO;AACf,WAAOA,SAAQ;AAAA,EACnB;AAEA,SAAOA,YAAWA,aAAY,MAAM;AAChC,QAAI,UAAUA,SAAQ;AACtB,QAAI,SAAS;AACT,aAAO;AAAA,IACX;AAEA,IAAAA,WAAUA,SAAQ;AAAA,EACtB;AAEA,SAAO;AACX;AASA,SAAS,cACL,WACA,MACA,WACU;AACV,MAAI,CAAC,WAAW;AACZ,WAAO;AAAA,EACX;AACA,MAAI,OAAmB,WAAW,WAAW,IAAI;AACjD,SAAO,MAAM;AACT,QAAI,UAAU,IAAI,GAAG;AACjB,aAAO;AAAA,IACX;AACA,WAAO,WAAW,MAAM,IAAI;AAAA,EAChC;AACA,SAAO;AACX;AAEA,SAAS,aAAa,gBAAuB,UAAwB;AAIjE,MACI,CAAC,SAAS,UACV,CAAC,CAAC,eAAe,OACjB,CAAC,CAAC,eAAe,UACjB,CAAC,CAAC,eAAe,OACjB,CAAC,CAAC,eAAe,IAAI,OACvB;AACE,UAAM,MAAM,eAAe;AAC3B,cAAU,KAAK,GAAG;AAElB,mBAAe,MAAM;AACrB,mBAAe,YAAY;AAC3B,mBAAe,gBAAgB;AAC/B,mBAAe,QAAQ;AACvB,mBAAe,MAAM,IAAI,WAAW,eAAe,IAAc;AACjE,QAAI,SAAS,gBAAgB,eAAe,KAAK,eAAe,OAAO,IAAI;AAE3E;AAAA,EACJ;AAEA,MAAI,WAAW,eAAe,KAAK,SAAS;AAC5C,MAAI,eAA6B;AACjC,MAAI,QAAQ;AACZ,QAAM,iBAAiB,oBAAI,IAAsD;AACjF,MAAI,kBAAkB;AACtB,MAAI,WAAW;AAGf,SAAO,iBAAiB;AACpB,UAAM,MAAM,gBAAgB,YAAY,OAAO;AAC/C,mBAAe,IAAI,KAAK,EAAE,OAAO,iBAAiB,OAAO,SAAS,CAAC;AACnE,sBAAkB,gBAAgB;AAClC;AAAA,EACJ;AAGA,WAAS,SAAS,GAAG,SAAS,SAAS,QAAQ,UAAU;AACrD,UAAM,eAAe,SAAS,MAAM;AACpC,UAAM,MAAM,aAAa,OAAO;AAChC,UAAM,WAAW,eAAe,IAAI,GAAG;AACvC,QAAI,WAAyB;AAE7B,QAAI,UAAU;AACV,YAAM,EAAE,OAAOC,WAAU,OAAO,OAAO,IAAI;AAC3C,qBAAe,OAAO,GAAG;AAEzB,UAAIA,UAAS,SAAS,aAAa,MAAM;AACrC,mBAAW,WAAW,cAAc,gBAAgBA,SAAQ;AAC5D,iBAAS,eAAe,WAAW;AAInC,cAAM,aACFA,UAAS,gBAAgB,gBACxB,OAAO,aAAa,SAAS,YAC1B,SAAS,iBAAiBA,UAAS,OAAO,aAAa,KAAK;AAEpE,YAAI,YAAY;AAEZ,mBAAS,YAAY;AACrB,mBAAS,QAAQA,UAAS;AAC1B,cAAI,UAAUA,UAAS;AACvB,iBAAO,SAAS;AACZ,oBAAQ,SAAS;AACjB,sBAAU,QAAQ;AAAA,UACtB;AAAA,QACJ;AACA,QAAAA,UAAS,MAAM;AACf,QAAAA,UAAS,QAAQ;AACjB,QAAAA,UAAS,UAAU;AACnB,QAAAA,UAAS,SAAS;AAAA,MACtB,OAAO;AAEH,kBAAU,KAAKA,SAAQ;AACvB,mBAAW,YAAY,cAAc,cAAc;AAAA,MACvD;AAAA,IACJ,OAAO;AAEH,iBAAW,YAAY,cAAc,cAAc;AAAA,IACvD;AAEA,QAAI,UAAU;AACV,UAAI,UAAU,EAAG,gBAAe,QAAQ;AAAA,UACnC,cAAc,UAAU;AAC7B,qBAAe;AACf;AAAA,IACJ;AAAA,EACJ;AAGA,iBAAe,QAAQ,CAAC,EAAE,MAAM,MAAM,UAAU,KAAK,KAAK,CAAC;AAC/D;AAEA,SAAS,YAAY,SAAqB,QAAsB;AAC5D,QAAM,WAAW,YAAY;AAC7B,WAAS,OAAO,QAAQ;AACxB,WAAS,SAAS;AAClB,WAAS,QAAQ,QAAQ;AACzB,WAAS,cAAc;AACvB,WAAS,YAAY;AACrB,MAAI,OAAO,QAAQ,SAAS,UAAU;AAClC,aAAS,iBAAiB;AAAA,EAC9B;AACA,SAAO;AACX;AAEA,SAAS,WAAW,SAAqB,QAAe,UAAwB;AAC5E,QAAM,WAAW,YAAY;AAC7B,WAAS,OAAO,QAAQ;AACxB,WAAS,SAAS;AAClB,WAAS,MAAM;AACf,WAAS,MAAM,SAAS;AACxB,WAAS,YAAY;AACrB,WAAS,QAAQ,QAAQ;AACzB,WAAS,UAAU,SAAS,UAAU;AACtC,WAAS,cAAc;AACvB,WAAS,iBAAiB,SAAS;AAEnC,QAAM,YAAY,SAAS;AAC3B,YAAU,UAAU;AACpB,WAAS,YAAY;AAErB,SAAO;AACX;;;AC9rBO,SAAS,aAAa,WAAkB,WAA2B;AACtE,MAAI,cAAc,UAAW,QAAO;AAEpC,QAAM,WAAW,OAAO,KAAK,SAAS;AACtC,QAAM,WAAW,OAAO,KAAK,SAAS;AAEtC,MAAI,SAAS,WAAW,SAAS,OAAQ,QAAO;AAEhD,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,UAAM,MAAM,SAAS,CAAC;AACtB,QAAI,UAAU,GAAG,MAAM,UAAU,GAAG,EAAG,QAAO;AAAA,EAClD;AAEA,SAAO;AACX;AAEO,SAAS,KACZ,WACA,YAA+D,cAC9D;AACD,WAAS,KAAK,OAA0B;AAEpC,WAAO,UAAU,KAAK;AAAA,EAC1B;AACA,OAAK,oBAAoB,IAAI;AAC7B,SAAO;AACX;;;ACtBA,IAAM,SAAS,CAAC,QAAa,KAAK,MAAM,KAAK,OAAO,IAAI,GAAI,IAAI;AAEhE,IAAM,IAAI;AAAA,EACN;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AACA,IAAM,IAAI;AAAA,EACN;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AACA,IAAM,IAAI;AAAA,EACN;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AAEA,IAAI,SAAS;AAGb,IAAM,YAAY,CAAC,UAAU;AACzB,QAAM,OAAO,IAAI,MAAM,KAAK;AAE5B,WAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC5B,SAAK,CAAC,IAAI;AAAA,MACN,IAAI;AAAA,MACJ,OAAO,GAAG,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC,IAAI,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC,IAAI,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;AAAA,IAC/E;AAAA,EACJ;AAEA,SAAO;AACX;AAEA,IAAM,eAAe,EAAE,MAAM,CAAC,GAAG,UAAU,EAAE;AAE7C,IAAM,cAAc,CAAC,OAAO,WAAW;AACnC,QAAM,EAAE,MAAM,SAAS,IAAI;AAE3B,UAAQ,OAAO,MAAM;AAAA,IACjB,KAAK;AACD,aAAO,EAAE,MAAM,UAAU,GAAG,GAAG,UAAU,EAAE;AAAA,IAC/C,KAAK;AACD,aAAO,EAAE,MAAM,UAAU,GAAK,GAAG,UAAU,EAAE;AAAA,IACjD,KAAK;AACD,aAAO,EAAE,MAAM,KAAK,OAAO,UAAU,GAAI,CAAC,GAAG,SAAS;AAAA,IAC1D,KAAK,UAAU;AACX,YAAM,UAAU,KAAK,MAAM,CAAC;AAE5B,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK,IAAI;AACzC,cAAM,IAAI,QAAQ,CAAC;AAEnB,gBAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,OAAO,EAAE,QAAQ,OAAO;AAAA,MACrD;AAEA,aAAO,EAAE,MAAM,SAAS,SAAS;AAAA,IACrC;AAAA,IACA,KAAK;AACD,aAAO,EAAE,MAAM,CAAC,GAAG,UAAU,EAAE;AAAA,IACnC,KAAK;AACD,YAAM,UAAU,CAAC,GAAG,IAAI;AACxB,UAAI,KAAK,SAAS,KAAK;AACnB,cAAM,KAAK,QAAQ,CAAC;AACpB,cAAM,OAAO,QAAQ,GAAG;AACxB,gBAAQ,CAAC,IAAI;AACb,gBAAQ,GAAG,IAAI;AAAA,MACnB;AACA,aAAO,EAAE,MAAM,SAAS,SAAS;AAAA,IACrC,KAAK,UAAU;AACX,YAAM,MAAM,KAAK,UAAU,CAAC,MAAW,EAAE,OAAO,OAAO,EAAE;AAEzD,aAAO,EAAE,MAAM,CAAC,GAAG,KAAK,MAAM,GAAG,GAAG,GAAG,GAAG,KAAK,MAAM,MAAM,CAAC,CAAC,GAAG,SAAS;AAAA,IAC7E;AAAA,IACA,KAAK;AACD,aAAO,EAAE,MAAM,UAAU,OAAO,GAAG;AAAA,IACvC;AACI,aAAO;AAAA,EACf;AACJ;AAEA,IAAM,MAAM;AAAA,EACR,CAAC,EAAE,UAAU,MAAM,SAAS,MACxB,oBAAC,QAAG,WAAW,WAAW,WAAW,MACjC,oBAAC,QAAG,WAAU,cAAY,KAAK,EAAG,GAClC,oBAAC,QAAG,WAAU,cACV,oBAAC,OAAE,SAAS,QAAQ,MAAM,MAAM,SAAS,EAAE,MAAM,UAAU,IAAI,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,KACxE,KAAK,KACV,CACJ,GACA,oBAAC,QAAG,WAAU,cACV,oBAAC,OAAE,SAAS,QAAQ,MAAM,MAAM,SAAS,EAAE,MAAM,UAAU,IAAI,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,KACzE,oBAAC,UAAK,WAAU,8BAA6B,eAAY,QAAO,CACpE,CACJ,GACA,oBAAC,QAAG,WAAU,YAAW,CAC7B;AAAA,EAEJ,CAAC,WAAW,cAAc;AACtB,WAAO,UAAU,aAAa,UAAU,YAAY,UAAU,SAAS,UAAU;AAAA,EACrF;AACJ;AAEA,IAAM,SAAS,CAAC,EAAE,IAAI,IAAI,MAAM,MAC5B,oBAAC,SAAI,WAAU,uBACX,oBAAC,YAAO,MAAK,UAAS,WAAU,6BAA4B,IAAQ,SAAS,MACxE,KACL,CACJ;AAGJ,IAAM,YAAY;AAAA;AAAA,EAEd,CAAC,EAAE,SAAS,MACR,oBAAC,SAAI,WAAU,eACX,oBAAC,SAAI,WAAU,SACX,oBAAC,SAAI,WAAU,cACX,oBAAC,YAAG,mBAAiB,CACzB,GACA,oBAAC,SAAI,WAAU,cACX,oBAAC,SAAI,WAAU,SACX;AAAA,IAAC;AAAA;AAAA,MACG,IAAG;AAAA,MACH,OAAM;AAAA,MACN,IAAI,MAAM,SAAS,EAAE,MAAM,MAAM,CAAC;AAAA;AAAA,EACtC,GACA;AAAA,IAAC;AAAA;AAAA,MACG,IAAG;AAAA,MACH,OAAM;AAAA,MACN,IAAI,MAAM,SAAS,EAAE,MAAM,WAAW,CAAC;AAAA;AAAA,EAC3C,GACA;AAAA,IAAC;AAAA;AAAA,MACG,IAAG;AAAA,MACH,OAAM;AAAA,MACN,IAAI,MAAM,SAAS,EAAE,MAAM,MAAM,CAAC;AAAA;AAAA,EACtC,GACA;AAAA,IAAC;AAAA;AAAA,MACG,IAAG;AAAA,MACH,OAAM;AAAA,MACN,IAAI,MAAM,SAAS,EAAE,MAAM,SAAS,CAAC;AAAA;AAAA,EACzC,GACA,oBAAC,UAAO,IAAG,SAAQ,OAAM,SAAQ,IAAI,MAAM,SAAS,EAAE,MAAM,QAAQ,CAAC,GAAG,GACxE;AAAA,IAAC;AAAA;AAAA,MACG,IAAG;AAAA,MACH,OAAM;AAAA,MACN,IAAI,MAAM,SAAS,EAAE,MAAM,YAAY,CAAC;AAAA;AAAA,EAC5C,CACJ,CACJ,CACJ,CACJ;AAAA,EAEJ,MAAM;AACV;AAEA,IAAM,OAAO,MAAM;AACf,QAAM,CAAC,EAAE,MAAM,SAAS,GAAG,QAAQ,IAAI,WAAW,aAAa,YAAY;AAE3E,SACI,oBAAC,SAAI,WAAU,eACX,oBAAC,aAAU,UAAoB,GAC/B,oBAAC,WAAM,WAAU,+CACb,oBAAC,eACI,KAAK,IAAI,CAAC,SACP;AAAA,IAAC;AAAA;AAAA,MACG,KAAK,KAAK;AAAA,MACV;AAAA,MACA,UAAU,aAAa,KAAK;AAAA,MAC5B;AAAA;AAAA,EACJ,CACH,CACL,CACJ,GACA,oBAAC,UAAK,WAAU,0CAAyC,eAAY,QAAO,CAChF;AAER;AAEA,WAAW,SAAS,eAAe,MAAM,GAAI,oBAAC,UAAK,CAAE;",
  "names": ["current", "oldFiber"]
}
