{
  "version": 3,
  "sources": ["../../src/constants.ts", "../../src/jsx.ts", "../../src/dom.ts", "../../src/hooks.ts", "../../src/memo.ts", "../../src/__bench__/app.tsx"],
  "sourcesContent": ["export const EMPTY_ARR: [] = [];\nexport const EMPTY_OBJ: {} = {};\n", "import { EMPTY_ARR } from './constants.js';\n\n// @TODO: Piggy back on react typings?\ndeclare global {\n    namespace JSX {\n        interface IntrinsicElements {\n            [elemName: string]: any;\n        }\n    }\n}\nexport const propsCompareFnSymbol = Symbol('propsCompareFn');\nexport const TEXT_ELEMENT = 'TEXT';\nexport type Primitive = undefined | null | string | number | boolean;\nexport type JSXElement = {\n    type: string | FC<Props>;\n    props: Props;\n    key: string | null;\n    children: JSXElement[];\n};\nexport type Props = {\n    children?: JSXElement[] | null;\n    [key: string]: unknown;\n};\nexport type FC<T = Props> = ((props: T) => JSXElement) & {\n    [propsCompareFnSymbol]?: (prevProps: T, nextProps: T) => boolean;\n};\n\n/**\n * Prepares children for an Element. Removes child items that cannot be rendered and flattens lists.\n * @param elements - Elements to process.\n * @param children - Array to accumulate valid children into.\n */\nfunction prepareChildren(\n    elements: (JSXElement | Primitive)[],\n    children: JSXElement[] = []\n): JSXElement[] {\n    // Create Element out of primitive children.\n    for (const element of elements) {\n        const elementType = typeof element;\n        if (elementType === 'object' && element) {\n            if (Array.isArray(element)) {\n                prepareChildren(element, children);\n            } else {\n                children.push(element as JSXElement);\n            }\n            continue;\n        }\n        if (elementType === 'string' || elementType === 'number') {\n            children.push({\n                type: TEXT_ELEMENT,\n                props: { nodeValue: element },\n                children: EMPTY_ARR,\n                key: null,\n            });\n        }\n    }\n\n    return children.length ? children : EMPTY_ARR;\n}\n\n/**\n * Creates a new JSX element with the specified type, props, and children.\n */\nexport function jsx<TProps extends Props | null>(\n    type: string | FC,\n    _props: any,\n    ..._children: (JSXElement | Primitive)[]\n): JSXElement {\n    const props = _props ?? {};\n    let children = null;\n    if (_children.length > 0) {\n        children = prepareChildren(_children);\n        props.children = children;\n    }\n\n    const element: JSXElement = {\n        type,\n        props,\n        children: children as JSXElement[],\n        key: props.key !== undefined ? props.key : null,\n    };\n    return element;\n}\n", "import { TEXT_ELEMENT, Props } from './jsx.js';\n\n/**\n * Creates a DOM node for a given type.\n * @param type - DOM tag or \"TEXT\".\n * @return DOM Node.\n */\nexport function createNode(type: string): Node {\n    return type === TEXT_ELEMENT ? document.createTextNode('') : document.createElement(type);\n}\n\nconst CHILDREN_PROP = 'children';\nconst FUNCTION_PREFIX = 'on';\n\nconst isEvent = (propName: string) => propName.startsWith(FUNCTION_PREFIX);\nconst isProp = (propName: string) => propName !== CHILDREN_PROP && !isEvent(propName);\nconst getEventName = (propName: string) => propName.toLowerCase().substring(2);\nconst getPropName = (propName: string) => (propName === 'className' ? 'class' : propName);\nconst canSetDirect = (propName: string, dom: Record<string, unknown>) => {\n    // TODO(val): snippet from preact, figure out the reason why these\n    // properties have to be set with setAttribute specifically.\n    return (\n        propName != 'width' &&\n        propName != 'height' &&\n        propName != 'href' &&\n        propName != 'list' &&\n        propName != 'form' &&\n        propName != 'tabIndex' &&\n        propName != 'download' &&\n        propName != 'rowSpan' &&\n        propName != 'colSpan' &&\n        propName != 'role' &&\n        propName != 'popover' &&\n        propName in dom\n    );\n};\n\ntype EventListener = EventListenerOrEventListenerObject;\n/**\n * Adds given properties to a DOM node. Reconciles new props with previous props if provided.\n * @param fiberRef - reference to the fiber that holds this dom node\n * @param dom - DOM node to add props to.\n * @param props -  Props to add.\n * @param prevProps - Previously applied props.\n */\nexport function addProps(fiberRef: unknown, node: Node, props: Props, prevProps: Props | null) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#node.text_node\n    if (node.nodeType === 3) {\n        if (node.nodeValue !== props.nodeValue) {\n            node.nodeValue = props.nodeValue as string;\n        }\n        return;\n    }\n\n    // @TODO: figure out why buttons and some other elements do not attach id\n    // Also figure out why value is not being reset on inputs\n\n    const element = node as Element & Record<string, unknown>;\n    if (prevProps) {\n        // Resets props that are completely removed.\n        for (let propToReset in prevProps) {\n            if (propToReset in props) {\n                continue;\n            }\n            if (isProp(propToReset)) {\n                const propName = getPropName(propToReset);\n                element.removeAttribute(propName);\n            } else if (isEvent(propToReset)) {\n                element.removeEventListener(\n                    getEventName(propToReset),\n                    prevProps[propToReset] as EventListener\n                );\n            }\n        }\n    }\n\n    // Add new props, compare to previous and update only if not equal\n    for (let propToAdd in props) {\n        if (prevProps && props[propToAdd] === prevProps[propToAdd]) {\n            continue;\n        }\n        const value = props[propToAdd];\n        if (isProp(propToAdd) && typeof value === 'string') {\n            const propName = getPropName(propToAdd);\n            if (canSetDirect(propName, element)) {\n                element[propName] = value;\n            } else {\n                element.setAttribute(propName, value);\n            }\n        } else if (isEvent(propToAdd)) {\n            const eventName = getEventName(propToAdd);\n            if (prevProps && prevProps[propToAdd]) {\n                element.removeEventListener(eventName, prevProps[propToAdd] as EventListener);\n            }\n            element.addEventListener(eventName, props[propToAdd] as EventListener);\n        }\n    }\n\n    // Add reference to the current fiber node\n    element['__fiberRef'] = fiberRef;\n}\n\nconst nodeProto = globalThis.Node?.prototype;\nconst nodeInsertBefore = nodeProto?.insertBefore;\nconst nodeRemoveChild = nodeProto?.removeChild;\nconst nodeAppendChild = nodeProto?.appendChild;\n\n/**\n * Remove child from a given parent.\n */\nfunction removeChild(parent: Node, child: Node) {\n    nodeRemoveChild.call(parent, child);\n}\n\n/**\n * Append child to a given parent.\n */\nfunction appendChild(parent: Node, child: Node) {\n    nodeAppendChild.call(parent, child);\n}\n\nfunction replaceWith(oldNode: ChildNode, newNode: Node) {\n    oldNode.replaceWith(newNode);\n}\n\nfunction insertBefore(parent: Node, node: Node, beforeNode: Node | null) {\n    nodeInsertBefore.call(parent, node, beforeNode);\n}\n\nexport default { createNode, addProps, removeChild, appendChild, replaceWith, insertBefore };\n", "export enum HookTypes {\n    state,\n    effect,\n    ref,\n    memo,\n}\n\nexport type StateHook<T> = {\n    type: HookTypes.state;\n    notify: () => void;\n    value: T;\n    pending?: { value: T };\n    setter: (value: T | ((prev: T) => T)) => void;\n};\n\nexport type EffectHook = {\n    type: HookTypes.effect;\n    cleanup?: () => void;\n    deps?: unknown[];\n};\n\nexport type RefHook<T> = {\n    type: HookTypes.ref;\n    value: { current: T };\n};\n\nexport type MemoHook<T> = {\n    type: HookTypes.memo;\n    value: T;\n    deps?: unknown[];\n};\n\nexport type Hooks = (StateHook<any> | MemoHook<any> | RefHook<any> | EffectHook)[];\nexport type CleanupFunc = () => void;\nexport type EffectFunc = () => void | CleanupFunc;\n\n/**\n * State for currently processed hooks. Reset right before the component's render.\n */\nconst current: {\n    hooks: Hooks;\n    notifyOnStateChange: () => void;\n    scheduleEffect: (effect: () => void, prevCleanup: (() => void) | null) => void;\n} = {\n    hooks: [],\n    notifyOnStateChange: () => {},\n    scheduleEffect: () => {},\n};\n\n/**\n * Index of currently executing hook within a component.\n * Starts with -1, each hook will increment this value in the beginning.\n */\nlet hookIndex = -1;\n\n/**\n * Starts to record hooks for a component.\n * @param hooks - Reference to the hooks array of the component.\n * @param notifyOnStateChange - Callback for when the state hook setters are called.\n * @param scheduleEffect - Callback for when the effect needs to be scheduled.\n */\nexport function processHooks(\n    hooks: typeof current.hooks,\n    notifyOnStateChange: typeof current.notifyOnStateChange,\n    scheduleEffect: typeof current.scheduleEffect\n) {\n    // Flush state updates\n    for (const hook of hooks) {\n        if (hook.type === HookTypes.state && hook.pending) {\n            hook.value = hook.pending.value;\n            hook.pending = undefined;\n        }\n    }\n    current.hooks = hooks;\n    current.notifyOnStateChange = notifyOnStateChange;\n    current.scheduleEffect = scheduleEffect;\n    hookIndex = -1;\n}\n\n/**\n * Stores state within the component.\n * @param initState\n * @returns Current value and a setter.\n */\nexport function useState<T>(\n    initState: T | (() => T)\n): [StateHook<T>['value'], StateHook<T>['setter']] {\n    hookIndex++;\n    const oldHook = current.hooks[hookIndex] as StateHook<T>;\n    if (oldHook) {\n        oldHook.notify = current.notifyOnStateChange;\n        return [oldHook.value, oldHook.setter];\n    }\n\n    const hook: StateHook<T> = {\n        type: HookTypes.state,\n        notify: current.notifyOnStateChange,\n        value: typeof initState === 'function' ? (initState as () => T)() : initState,\n        setter(value) {\n            let lastValue = hook.pending ? hook.pending.value : hook.value;\n            let setterFn = typeof value === 'function' ? (value as (prev: T) => T) : undefined;\n            let pendingValue = setterFn ? setterFn(lastValue) : (value as T);\n            if (pendingValue === lastValue) return;\n            hook.pending = { value: pendingValue };\n            hook.notify();\n        },\n    };\n\n    current.hooks.push(hook);\n    return [hook.value, hook.setter];\n}\n\n/**\n * Helper to collect all effect cleanup functions from the hooks array.\n * @TODO: separate effects and state from a single hooks array?\n * @param hooks - Hooks array to collect effect cleanups from.\n * @param cleanups - Reference to the array to collect the cleanups in.\n */\nexport function collectEffectCleanups(hooks: Hooks) {\n    let cleanupFuncs: CleanupFunc[] | undefined;\n    for (let hook of hooks) {\n        if (hook.type === HookTypes.effect && hook.cleanup) {\n            (cleanupFuncs ?? (cleanupFuncs = [])).push(hook.cleanup);\n        }\n    }\n    return cleanupFuncs;\n}\n\n/**\n * Runs the effect and stores the cleanup function returned on the same hook.\n * @param effect - Effect to run.\n * @param hook - Hook to store the cleanup function on.\n */\nfunction executeEffect(effect: EffectFunc, hook: EffectHook) {\n    const cleanup = effect();\n    if (typeof cleanup === 'function') {\n        hook.cleanup = cleanup;\n    }\n}\n\n/**\n * Compares if new hook deps are equal to the prev deps.\n * If deps array is missing this function will return false.\n * @param newDeps - new hook deps.\n * @param prevDeps - previous hook deps.\n * @returns True if dependencies are equal.\n */\nfunction areDepsEqual(newDeps?: unknown[], prevDeps?: unknown[]): boolean {\n    if (!newDeps || !prevDeps) {\n        return false;\n    }\n\n    return (\n        newDeps.length === prevDeps.length &&\n        (newDeps.length === 0 || newDeps.every((newDep, index) => newDep === prevDeps[index]))\n    );\n}\n\n/**\n * Schedules effects to run after the component is rendered.\n * @param effect - Effect function to run. Can return an optional cleanup to run before re-execution or unmount.\n * @param deps - Array of dependencies for the effect. Effect will be re-run when these change.\n */\nexport function useEffect(effect: EffectFunc, deps?: unknown[]) {\n    hookIndex++;\n    const scheduleEffect = current.scheduleEffect;\n    const oldHook = current.hooks[hookIndex] as EffectHook;\n    if (oldHook) {\n        if (!areDepsEqual(deps, oldHook.deps)) {\n            scheduleEffect(() => executeEffect(effect, oldHook), oldHook.cleanup ?? null);\n            oldHook.deps = deps;\n        }\n        return;\n    }\n\n    const hook: EffectHook = {\n        type: HookTypes.effect,\n        deps,\n    };\n\n    current.hooks.push(hook);\n    scheduleEffect(() => executeEffect(effect, hook), null);\n}\n\n/**\n * Remembers the value returned from the callback passed.\n * Returns the same value between renders if dependencies haven't changed.\n * @param valueFn - Callback to run to get the value.\n * @param deps - Array of dependencies to compare with the previous run.\n */\nexport function useMemo<T>(valueFn: () => T, deps: unknown[]): T {\n    hookIndex++;\n    const oldHook = current.hooks[hookIndex] as MemoHook<T>;\n    if (oldHook) {\n        if (!areDepsEqual(deps, oldHook.deps)) {\n            oldHook.deps = deps;\n            oldHook.value = valueFn();\n        }\n        return oldHook.value;\n    }\n\n    const hook: MemoHook<T> = {\n        type: HookTypes.memo,\n        deps,\n        value: valueFn(),\n    };\n\n    current.hooks.push(hook);\n    return hook.value;\n}\n\n/**\n * Remembers the value passed and returns a mutable ref object.\n * @param init - Initial value to store in the ref.\n */\nexport function useRef<T>(initialValue: T): { current: T } {\n    hookIndex++;\n    const oldHook = current.hooks[hookIndex] as RefHook<T>;\n    if (oldHook) {\n        return oldHook.value;\n    }\n\n    const hook: RefHook<T> = {\n        type: HookTypes.ref,\n        value: { current: initialValue },\n    };\n\n    current.hooks.push(hook);\n    return hook.value;\n}\n\nexport type Reducer<S, A> = (state: S, action: A) => S;\nexport type Dispatch<A> = (action: A) => void;\n\n/**\n *  Alternative to useState for more complex state management.\n * @param reducer - Function to handle state changes.\n * @param initStateOrArg - Argument for the initialization function or initial state.\n * @param initFn - Function to initialize the state.\n */\nexport function useReducer<TState, TAction, TInitArg>(\n    reducer: Reducer<TState, TAction>,\n    initStateOrArg: TInitArg | TState,\n    initFn?: (arg: TInitArg | TState) => TState\n): [TState, Dispatch<TAction>] {\n    const ref = useRef<{ dispatch: Dispatch<TAction> | undefined; initState: TState }>({\n        dispatch: undefined,\n        initState: initFn ? initFn(initStateOrArg) : (initStateOrArg as TState),\n    });\n    const [state, setState] = useState(ref.current.initState);\n    if (ref.current.dispatch) {\n        return [state, ref.current.dispatch];\n    }\n    function dispatch(action: TAction) {\n        setState((prevState) => reducer(prevState, action));\n    }\n    ref.current.dispatch = dispatch;\n    return [state, dispatch];\n}\n", "import { JSXElement, Props, propsCompareFnSymbol } from './jsx.js';\n\nexport function shallowEqual(prevProps: Props, nextProps: Props): boolean {\n    if (prevProps === nextProps) return true;\n\n    const prevKeys = Object.keys(prevProps);\n    const nextKeys = Object.keys(nextProps);\n\n    if (prevKeys.length !== nextKeys.length) return false;\n\n    for (let i = 0; i < prevKeys.length; i++) {\n        const key = prevKeys[i];\n        if (prevProps[key] !== nextProps[key]) return false;\n    }\n\n    return true;\n}\n\nexport function memo<T extends (...args: any[]) => any, TProps extends Props = Parameters<T>[0]>(\n    Component: T,\n    compareFn: (prevProps: TProps, nextProps: TProps) => boolean = shallowEqual\n): T {\n    function Memo(props: Props): JSXElement {\n        // @ts-ignore\n        return Component(props);\n    }\n    Memo[propsCompareFnSymbol] = compareFn;\n    return Memo as unknown as T;\n}\n", "/** @jsx jsx */\nimport { jsx, memo, Dispatch, useReducer, useMemo, useRef } from '../index.js';\n\nconst random = (max: number) => Math.round(Math.random() * 1000) % max;\n\nconst A = [\n    'pretty',\n    'large',\n    'big',\n    'small',\n    'tall',\n    'short',\n    'long',\n    'handsome',\n    'plain',\n    'quaint',\n    'clean',\n    'elegant',\n    'easy',\n    'angry',\n    'crazy',\n    'helpful',\n    'mushy',\n    'odd',\n    'unsightly',\n    'adorable',\n    'important',\n    'inexpensive',\n    'cheap',\n    'expensive',\n    'fancy',\n];\nconst C = [\n    'red',\n    'yellow',\n    'blue',\n    'green',\n    'pink',\n    'brown',\n    'purple',\n    'brown',\n    'white',\n    'black',\n    'orange',\n];\nconst N = [\n    'table',\n    'chair',\n    'house',\n    'bbq',\n    'desk',\n    'car',\n    'pony',\n    'cookie',\n    'sandwich',\n    'burger',\n    'pizza',\n    'mouse',\n    'keyboard',\n];\n\nlet nextId = 1;\n\nconst buildData = (count: number) => {\n    const data = new Array<{ id: number; label: string }>(count);\n\n    for (let i = 0; i < count; i++) {\n        data[i] = {\n            id: nextId++,\n            label: `${A[random(A.length)]} ${C[random(C.length)]} ${N[random(N.length)]}`,\n        };\n    }\n\n    return data;\n};\n\nconst initialState: {\n    data: ReturnType<typeof buildData>;\n    selected: number;\n} = {\n    data: [],\n    selected: 0,\n};\n\nexport type Action =\n    | {\n          type: 'RUN' | 'RUN_LOTS' | 'ADD' | 'UPDATE' | 'CLEAR' | 'SWAP_ROWS';\n      }\n    | { type: 'SELECT' | 'REMOVE'; id: number };\n\nexport type BenchDispatch = Dispatch<Action>;\n\nconst listReducer = (state: typeof initialState, action: Action) => {\n    const { data, selected } = state;\n\n    switch (action.type) {\n        case 'RUN':\n            return { data: buildData(1000), selected: 0 };\n        case 'RUN_LOTS':\n            return { data: buildData(10000), selected: 0 };\n        case 'ADD':\n            return { data: data.concat(buildData(1000)), selected };\n        case 'UPDATE': {\n            const newData = data.slice(0);\n\n            for (let i = 0; i < newData.length; i += 10) {\n                const r = newData[i];\n\n                newData[i] = { id: r.id, label: r.label + ' !!!' };\n            }\n\n            return { data: newData, selected };\n        }\n        case 'CLEAR':\n            return { data: [], selected: 0 };\n        case 'SWAP_ROWS':\n            const newdata = [...data];\n            if (data.length > 998) {\n                const d1 = newdata[1];\n                const d998 = newdata[998];\n                newdata[1] = d998;\n                newdata[998] = d1;\n            }\n            return { data: newdata, selected };\n        case 'REMOVE': {\n            const idx = data.findIndex((d: any) => d.id === action.id);\n\n            return { data: [...data.slice(0, idx), ...data.slice(idx + 1)], selected };\n        }\n        case 'SELECT':\n            return { data, selected: action.id };\n        default:\n            return state;\n    }\n};\n\nconst Row = memo(\n    ({\n        selected,\n        item,\n        dispatch,\n    }: {\n        key: string;\n        selected: boolean;\n        item: any;\n        dispatch: any;\n    }) => {\n        return (\n            <tr className={selected ? 'danger' : ''}>\n                <td className=\"col-md-1\">{item.id}</td>\n                <td className=\"col-md-4\">\n                    <a onClick={useMemo(() => () => dispatch({ type: 'SELECT', id: item.id }), [])}>\n                        {item.label}\n                    </a>\n                </td>\n                <td className=\"col-md-1\">\n                    <a onClick={useMemo(() => () => dispatch({ type: 'REMOVE', id: item.id }), [])}>\n                        <span className=\"glyphicon glyphicon-remove\" aria-hidden=\"true\" />\n                    </a>\n                </td>\n                <td className=\"col-md-6\" />\n            </tr>\n        );\n    },\n    (prevProps, nextProps) => {\n        return prevProps.selected === nextProps.selected && prevProps.item === nextProps.item;\n    }\n);\n\nconst Button = ({ id, cb, title }: { id: string; cb: any; title: string }) => (\n    <div className=\"col-sm-6 smallpad\">\n        <button type=\"button\" className=\"btn btn-primary btn-block\" id={id} onClick={cb}>\n            {title}\n        </button>\n    </div>\n);\n\nconst Jumbotron = memo(\n    ({ dispatch }: { dispatch: any }) => (\n        <div className=\"jumbotron\">\n            <div className=\"row\">\n                <div className=\"col-md-6\">\n                    <h1>React Hooks keyed</h1>\n                </div>\n                <div className=\"col-md-6\">\n                    <div className=\"row\">\n                        <Button\n                            id=\"run\"\n                            title=\"Create 1,000 rows\"\n                            cb={() => dispatch({ type: 'RUN' })}\n                        />\n                        <Button\n                            id=\"runlots\"\n                            title=\"Create 10,000 rows\"\n                            cb={() => dispatch({ type: 'RUN_LOTS' })}\n                        />\n                        <Button\n                            id=\"add\"\n                            title=\"Append 1,000 rows\"\n                            cb={() => dispatch({ type: 'ADD' })}\n                        />\n                        <Button\n                            id=\"update\"\n                            title=\"Update every 10th row\"\n                            cb={() => dispatch({ type: 'UPDATE' })}\n                        />\n                        <Button id=\"clear\" title=\"Clear\" cb={() => dispatch({ type: 'CLEAR' })} />\n                        <Button\n                            id=\"swaprows\"\n                            title=\"Swap Rows\"\n                            cb={() => dispatch({ type: 'SWAP_ROWS' })}\n                        />\n                    </div>\n                </div>\n            </div>\n        </div>\n    ),\n    () => true\n);\n\nexport const BenchMain = ({\n    dispatchRef,\n}: {\n    dispatchRef: { current: null | Dispatch<Action> };\n}) => {\n    const [{ data, selected }, dispatch] = useReducer(listReducer, initialState);\n    dispatchRef.current = dispatch;\n    return (\n        <div className=\"container\">\n            <Jumbotron dispatch={dispatch} />\n            <table className=\"table table-hover table-striped test-data\">\n                <tbody>\n                    {data.map((item: any) => (\n                        <Row\n                            key={item.id}\n                            item={item}\n                            selected={selected === item.id}\n                            dispatch={dispatch}\n                        />\n                    ))}\n                </tbody>\n            </table>\n            <span className=\"preloadicon glyphicon glyphicon-remove\" aria-hidden=\"true\" />\n        </div>\n    );\n};\n\n// createRoot(document.getElementById('root')!, <BenchMain />);\n"],
  "mappings": "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",
  "names": []
}
